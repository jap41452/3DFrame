<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Frame Analysis (v2.2: Physics Fixed)</title>
<style>
  :root{
    --bg:#ffffff;
    --panel:#f5f6f8;
    --panel2:#ffffff;
    --line:#d7dbe3;
    --text:#111827;
    --muted:#5b6472;
    --accent:#2563eb;
    --warn:#b45309;
    --err:#b91c1c;
    --ok:#166534;
  }
  html,body{height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  #app{height:100%; display:grid; grid-template-columns: 375px 1fr; grid-template-rows: 1fr; gap:10px; padding:10px; box-sizing:border-box;}
  #ui{background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:10px; box-sizing:border-box; overflow-y:auto;}
  #rightColumn{display:flex; flex-direction:column; gap:10px; min-width:0;}
  #viewportWrap{flex:1; background:var(--panel2); border:1px solid var(--line); border-radius:10px; padding:8px; box-sizing:border-box; display:flex; flex-direction:column; gap:6px; min-height:400px;}
  #canvas{width:100%; height:100%; background:#ffffff; border:1px solid var(--line); border-radius:8px; display:block;}
  #stressPanel{background:var(--panel2); border:1px solid var(--line); border-radius:10px; padding:10px; box-sizing:border-box; max-height:300px; overflow-y:auto;}
  #stressContent{font-size:12px;}
  .stressTable{width:100%; border-collapse:collapse; font-size:11px;}
  .stressTable th{background:var(--panel); padding:6px 8px; text-align:left; font-weight:600; border-bottom:2px solid var(--line);}
  .stressTable td{padding:6px 8px; border-bottom:1px solid var(--line);}
  .stressTable tr:hover{background:rgba(0,0,0,0.02);}
  .stressLabel{font-weight:600; color:var(--text); margin-bottom:4px;}
  .stressValue{color:var(--muted);}
  h3{margin:0 0 8px 0; font-size:14px; font-weight:700;}
  .sectionTitle{font-size:12px; font-weight:700; margin:10px 0 6px; color:#1f2937;}
  button{width:100%; padding:8px 10px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text); font-weight:700; cursor:pointer;}
  button:hover{border-color:#b9c3d6;}
  button:disabled{opacity:0.55; cursor:not-allowed;}
  .hint{font-size:12px; color:var(--muted); line-height:1.25; margin:8px 0;}
  .small{font-size:12px; color:var(--muted);}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #cfd6e2; background:#ffffff; font-size:12px; color:var(--muted);}
  #summary{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;}
  #log{margin-top:10px; padding:8px; background:#ffffff; border:1px solid var(--line); border-radius:8px; height:190px; overflow:auto; font-size:12px; line-height:1.25; white-space:pre-wrap;}
  .log-warn{color:var(--warn);} .log-err{color:var(--err);} .log-ok{color:var(--ok);}
  #vpBar{display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted); padding:0 2px;}
  #selInfo{font-size:11px; color:var(--text); min-height:16px; padding:4px 6px; background:rgba(255,255,255,0.9); border-radius:6px; font-weight:500; line-height:1.3; word-break:break-word;}
  textarea{width:100%; box-sizing:border-box; min-height:72px; max-height:140px; resize:vertical; padding:8px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text);
           font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:11px; line-height:1.2;}
  .btnRow{display:flex; gap:8px;} .btnRow button{width:50%;}
  .mini{padding:7px 8px; font-size:12px;}
  .sep{height:10px;}
  .sliderWrap{margin-top:8px;}
  input[type="range"]{width:100%;}
  .kv{display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--muted);}
</style>
</head>

<body>
<div id="app">
  <div id="ui">
    <h3>Frame Definition</h3>

    <div class="sectionTitle">Nodes</div>
    <button id="btnImportNodes">Load Nodes File</button>
    <input id="fileNodes" type="file" accept=".txt,.tsv,.csv" style="display:none" />
    <div class="hint small">Paste from Excel (tab-delimited) or CSV. Header row optional.</div>
    <textarea id="taNodes" placeholder="Paste node table: node  x  y  z  delX  delY  delZ  thetaXX  thetaYY  thetaZZ  Fx  Fy  Fz"></textarea>
    <div class="btnRow">
      <button id="btnParseNodes" class="mini">Use Nodes</button>
      <button id="btnResetNodes" class="mini">Reset</button>
    </div>

    <div class="sectionTitle">Segments</div>
    <button id="btnImportElems">Load Segments File</button>
    <input id="fileElems" type="file" accept=".txt,.tsv,.csv" style="display:none" />
    <div class="hint small">elem  ni  nj  E  G  Izz  Iyy  Jyz  Ayz  x3  y3  z3</div>
    <textarea id="taElems" placeholder="Paste segment table: elem  ni  nj  E  G  Izz  Iyy  Jyz  Ayz  x3  y3  z3"></textarea>
    <div class="btnRow">
      <button id="btnParseElems" class="mini">Use Segments</button>
      <button id="btnResetElems" class="mini">Reset</button>
    </div>

    <div class="sep"></div>

    <button id="btnDraw" disabled>Draw / Edit Frame</button>
    <div class="sep"></div>
    <button id="btnSolve" disabled>Static Solve (10 subsegments/segment)</button>

    <div class="sliderWrap">
      <div class="kv">
        <div>Deflection scale</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="defScaleInput" type="number" step="0.1" value="0" disabled 
                 style="width:70px; padding:4px 6px; border-radius:6px; border:1px solid #cfd6e2; font-size:12px;" />
          <span id="defScaleLabel" style="font-size:11px; color:var(--muted);">/ <span id="defScaleMax">200</span></span>
        </div>
      </div>
      <input id="defScale" type="range" min="0" max="200" step="1" value="0" disabled />
      <div style="display:flex; gap:8px; margin-top:4px;">
        <input id="defScaleMaxInput" type="number" step="10" value="200" placeholder="Max" 
               style="width:80px; padding:4px 6px; border-radius:6px; border:1px solid #cfd6e2; font-size:11px;" />
        <button id="btnSetMaxScale" class="mini" style="flex:1;">Set Slider Max</button>
      </div>
      <div class="hint small">Adjust scale to view deflected shape. Use input box for precise values.</div>
    </div>

    <div class="hint">Viewport: Left-drag = orbit, Right-drag = pan, Wheel = zoom. Hover nodes/segments for info, click to pin.</div>
    <div id="summary"></div>
    <div id="log"></div>
  </div>

  <div id="rightColumn">
    <div id="viewportWrap">
      <div id="vpBar">
        <div>3D Viewport</div>
        <div id="status" class="small">Idle</div>
      </div>
      <canvas id="canvas"></canvas>
      <div id="selInfo"></div>
    </div>

    <div id="stressPanel">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <h3 style="margin:0;">Element Analysis</h3>
        <div style="display:flex; gap:8px; align-items:center;">
          <select id="stressViewSelector" style="padding:4px 8px; border-radius:6px; border:1px solid var(--line); font-size:11px; background:#fff;" disabled>
            <option value="table">Stress Table</option>
            <option value="moment">Moment Diagrams</option>
            <option value="shear">Shear Diagrams</option>
            <option value="combined">Combined Stress</option>
          </select>
          <div class="small" style="color:var(--muted);">Click a segment</div>
        </div>
      </div>
      <div id="stressContent">
        <div style="color:var(--muted); font-size:12px; text-align:center; padding:20px;">
          No segment selected. Click on a segment in the viewport to view its analysis.
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   3D FRAME ANALYSIS v2.2
   FIXED: Zero-clamping for pinned supports
   FIXED: Iyy/Izz usage in stress formula
   ========================= */

/* =========================
   Defaults
   ========================= */
const DEFAULT_NODES_TEXT =
`node	x	y	z	delX	delY	delZ	thetaXX	thetaYY	thetaZZ	Fx	Fy	Fz
1	0	0	0	0	0	0	0	0	0
2	0	0	10
3	12	0	0	0	0	0	0	0	0
4	12	0	12
5	0	10	0	0	0	0
6	0	10	12							100
7	12	10	0	0	0	0
8	12	10	12`;

const DEFAULT_ELEMS_TEXT =
`elem	ni	nj	E	G	Izz	Iyy	Jyz	Ayz	x3	y3	z3
1	1	2	12000000	4000000	1	1	1	2	1	2	3
2	3	4	12000000	4000000	1	1	1	2	1	2	3
3	5	6	12000000	4000000	1	1	1	2	1	2	3
4	7	8	12000000	4000000	1	1	1	2	1	2	3
5	4	8	12000000	4000000	1	1	1	2	1	2	3
6	2	4	12000000	4000000	1	1	1	2	1	2	3
7	2	6	12000000	4000000	1	1	1	2	1	2	3
8	6	8	12000000	4000000	1	1	1	2	1	2	3`;

/* =========================
   Model
   ========================= */
const Model = {
  nodes: [],
  elems: [],
  nodeById: new Map(),
  elemById: new Map(),
  lastSolution: null,
  isDrawn: false
};

const View = {
  cam: {
    distance: 50,
    azimuth: 35 * Math.PI / 180,   // horizontal rotation
    elevation: 30 * Math.PI / 180, // vertical rotation
    centerX: 6,
    centerY: 5,
    centerZ: 6
  },
  isInteractive: false,
  dragging: false,
  dragButton: 0,
  dragStart: {x:0, y:0, azimuth:0, elevation:0, centerX:0, centerY:0, centerZ:0},
  hoveredNode: null,
  pinnedNode: null,
  hoveredElem: null,
  pinnedElem: null,
  selectedSegmentForAnalysis: null,
  mousePos: {x:0, y:0}
};

/* =========================
   DOM
   ========================= */
const el = {
  btnImportNodes: document.getElementById('btnImportNodes'),
  btnImportElems: document.getElementById('btnImportElems'),
  btnDraw: document.getElementById('btnDraw'),
  btnSolve: document.getElementById('btnSolve'),
  fileNodes: document.getElementById('fileNodes'),
  fileElems: document.getElementById('fileElems'),
  taNodes: document.getElementById('taNodes'),
  taElems: document.getElementById('taElems'),
  btnParseNodes: document.getElementById('btnParseNodes'),
  btnParseElems: document.getElementById('btnParseElems'),
  btnResetNodes: document.getElementById('btnResetNodes'),
  btnResetElems: document.getElementById('btnResetElems'),
  log: document.getElementById('log'),
  summary: document.getElementById('summary'),
  canvas: document.getElementById('canvas'),
  status: document.getElementById('status'),
  selInfo: document.getElementById('selInfo'),
  defScale: document.getElementById('defScale'),
  defScaleLabel: document.getElementById('defScaleLabel'),
  defScaleInput: document.getElementById('defScaleInput'),
  defScaleMax: document.getElementById('defScaleMax'),
  defScaleMaxInput: document.getElementById('defScaleMaxInput'),
  btnSetMaxScale: document.getElementById('btnSetMaxScale'),
  stressContent: document.getElementById('stressContent'),
  stressViewSelector: document.getElementById('stressViewSelector')
};
const ctx = el.canvas.getContext('2d');

/* =========================
   Canvas sizing
   ========================= */
function resizeCanvas(){
  const rect = el.canvas.getBoundingClientRect();
  el.canvas.width = rect.width;
  el.canvas.height = rect.height;
  if(Model.isDrawn) drawPrimary();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* =========================
   Logging
   ========================= */
function logClear(){ el.log.textContent = ""; }
function logLine(msg, cls=null){
  const d = document.createElement('div');
  d.textContent = msg;
  if(cls) d.className = cls;
  el.log.appendChild(d);
  el.log.scrollTop = el.log.scrollHeight;
}
function setStatus(msg){ el.status.textContent = msg; }
function badge(text){
  const b = document.createElement('span');
  b.className = 'badge';
  b.textContent = text;
  return b;
}
function renderSummary(){
  const n = Model.nodes.length;
  const m = Model.elems.length;
  const prescribed = Model.nodes.reduce((acc,nd)=>acc +
    (nd.ux.prescribed?1:0)+(nd.uy.prescribed?1:0)+(nd.uz.prescribed?1:0)+
    (nd.rx.prescribed?1:0)+(nd.ry.prescribed?1:0)+(nd.rz.prescribed?1:0), 0);
  const loads = Model.nodes.reduce((acc,nd)=>acc + 
    ((nd.loads.fx||0)!==0?1:0)+((nd.loads.fy||0)!==0?1:0)+((nd.loads.fz||0)!==0?1:0), 0);

  el.summary.innerHTML = "";
  el.summary.appendChild(badge(`Nodes: ${n}`));
  el.summary.appendChild(badge(`Segments: ${m}`));
  el.summary.appendChild(badge(`Prescribed DOF: ${prescribed}`));
  el.summary.appendChild(badge(`Load terms: ${loads}`));

  if(Model.lastSolution){
    const exN = Model.lastSolution.expanded.nodes.length;
    const exE = Model.lastSolution.expanded.elems.length;
    el.summary.appendChild(badge(`Expanded: ${exN} nodes, ${exE} segs`));
  }
}

/* =========================
   Parsing utilities
   ========================= */
function isBlankToken(t){
  if(t==null) return true;
  const s = String(t).trim();
  return s === "" || s === "." || /^na$/i.test(s);
}
function toNumberOrNull(t){
  if(isBlankToken(t)) return null;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function toNumberOrZero(t){
  if(isBlankToken(t)) return 0;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function splitLine(line){
  if(line.includes("\t")) return line.split("\t");
  if(line.includes(","))  return line.split(",");
  return line.trim().split(/\s+/);
}
function isCommentOrBlank(line){
  const s = line.trim();
  return s === "" || s.startsWith("#") || s.startsWith("//");
}
function detectHeader(tokens){
  return tokens.some(t => /[A-Za-z]/.test(String(t)));
}
function normalizeHeader(h){
  return String(h).trim().toLowerCase()
    .replace(/\s+/g,'')
    .replace(/_/g,'')
    .replace(/-/g,'');
}

/* =========================
   Parse nodes: node x y z delX delY delZ thetaXX thetaYY thetaZZ Fx Fy Fz
   ========================= */
function parseNodes(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No node data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const nodes = [];
  const seen = new Set();
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];
    const nodeTok = get(toks,"node",0) ?? get(toks,"nodeno",0) ?? toks[0];
    const id = parseInt(String(nodeTok).trim(), 10);
    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid node number "${nodeTok}"`);
    if(seen.has(id)) throw new Error(`Row ${r+1}: duplicate node number ${id}`);
    seen.add(id);

    const x = toNumberOrNull(get(toks,"x",1));
    const y = toNumberOrNull(get(toks,"y",2));
    const z = toNumberOrNull(get(toks,"z",3));
    if(!Number.isFinite(x)) throw new Error(`Row ${r+1}: invalid X`);
    if(!Number.isFinite(y)) throw new Error(`Row ${r+1}: invalid Y`);
    if(!Number.isFinite(z)) throw new Error(`Row ${r+1}: invalid Z`);

    const dx = toNumberOrNull(get(toks,"delx",4) ?? get(toks,"dx",4));
    const dy = toNumberOrNull(get(toks,"dely",5) ?? get(toks,"dy",5));
    const dz = toNumberOrNull(get(toks,"delz",6) ?? get(toks,"dz",6));
    
    const thx = toNumberOrNull(get(toks,"thetaxx",7) ?? get(toks,"thxx",7) ?? get(toks,"rx",7));
    const thy = toNumberOrNull(get(toks,"thetayy",8) ?? get(toks,"thyy",8) ?? get(toks,"ry",8));
    const thz = toNumberOrNull(get(toks,"thetazz",9) ?? get(toks,"thzz",9) ?? get(toks,"rz",9));

    const fx = toNumberOrZero(get(toks,"fx",10));
    const fy = toNumberOrZero(get(toks,"fy",11));
    const fz = toNumberOrZero(get(toks,"fz",12));

    if(!Number.isFinite(fx)) throw new Error(`Row ${r+1}: invalid Fx`);
    if(!Number.isFinite(fy)) throw new Error(`Row ${r+1}: invalid Fy`);
    if(!Number.isFinite(fz)) throw new Error(`Row ${r+1}: invalid Fz`);
    if(dx!==null && !Number.isFinite(dx)) throw new Error(`Row ${r+1}: invalid delX`);
    if(dy!==null && !Number.isFinite(dy)) throw new Error(`Row ${r+1}: invalid delY`);
    if(dz!==null && !Number.isFinite(dz)) throw new Error(`Row ${r+1}: invalid delZ`);
    if(thx!==null && !Number.isFinite(thx)) throw new Error(`Row ${r+1}: invalid thetaXX`);
    if(thy!==null && !Number.isFinite(thy)) throw new Error(`Row ${r+1}: invalid thetaYY`);
    if(thz!==null && !Number.isFinite(thz)) throw new Error(`Row ${r+1}: invalid thetaZZ`);

    nodes.push({
      id, x, y, z,
      ux: { prescribed: dx!==null, value: dx ?? 0 },
      uy: { prescribed: dy!==null, value: dy ?? 0 },
      uz: { prescribed: dz!==null, value: dz ?? 0 },
      rx: { prescribed: thx!==null, value: thx ?? 0 },
      ry: { prescribed: thy!==null, value: thy ?? 0 },
      rz: { prescribed: thz!==null, value: thz ?? 0 },
      loads: { fx, fy, fz }
    });
  }
  return nodes;
}

/* =========================
   Parse elems: elem ni nj E G Izz Iyy Jyz Ayz x3 y3 z3
   ========================= */
function parseElems(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No segment data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const elems = [];
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];

    const elemTok = get(toks,"elem",0) ?? get(toks,"element",0) ?? toks[0];
    const niTok = get(toks,"ni",1) ?? get(toks,"nodei",1) ?? toks[1];
    const njTok = get(toks,"nj",2) ?? get(toks,"nodej",2) ?? toks[2];
    
    const id = parseInt(String(elemTok).trim(), 10);
    const ni = parseInt(String(niTok).trim(),10);
    const nj = parseInt(String(njTok).trim(),10);
    
    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid element number`);
    if(!Number.isFinite(ni) || !Number.isFinite(nj)) throw new Error(`Row ${r+1}: invalid node i/j`);
    if(ni === nj) throw new Error(`Row ${r+1}: ni and nj cannot be the same (${ni})`);

    const E = toNumberOrNull(get(toks,"e",3));
    const G = toNumberOrNull(get(toks,"g",4));
    const Izz = toNumberOrNull(get(toks,"izz",5));
    const Iyy = toNumberOrNull(get(toks,"iyy",6));
    const Jyz = toNumberOrNull(get(toks,"jyz",7) ?? get(toks,"j",7));
    const Ayz = toNumberOrNull(get(toks,"ayz",8) ?? get(toks,"a",8));
    
    const x3 = toNumberOrNull(get(toks,"x3",9));
    const y3 = toNumberOrNull(get(toks,"y3",10));
    const z3 = toNumberOrNull(get(toks,"z3",11));

    if(!Number.isFinite(E) || E<=0) throw new Error(`Row ${r+1}: invalid E (must be > 0)`);
    if(!Number.isFinite(G) || G<=0) throw new Error(`Row ${r+1}: invalid G (must be > 0)`);
    if(!Number.isFinite(Izz) || Izz<=0) throw new Error(`Row ${r+1}: invalid Izz (must be > 0)`);
    if(!Number.isFinite(Iyy) || Iyy<=0) throw new Error(`Row ${r+1}: invalid Iyy (must be > 0)`);
    if(!Number.isFinite(Jyz) || Jyz<=0) throw new Error(`Row ${r+1}: invalid Jyz (must be > 0)`);
    if(!Number.isFinite(Ayz) || Ayz<=0) throw new Error(`Row ${r+1}: invalid Ayz (must be > 0)`);
    if(!Number.isFinite(x3)) throw new Error(`Row ${r+1}: invalid x3`);
    if(!Number.isFinite(y3)) throw new Error(`Row ${r+1}: invalid y3`);
    if(!Number.isFinite(z3)) throw new Error(`Row ${r+1}: invalid z3`);

    elems.push({ id, ni, nj, E, G, Izz, Iyy, Jyz, Ayz, x3, y3, z3 });
  }
  return elems;
}

/* =========================
   Install / invalidate
   ========================= */
function invalidateSolutionAndDefScale(){
  Model.lastSolution = null;
  el.defScale.value = 0;
  el.defScaleInput.value = 0;
  el.defScale.disabled = true;
  el.defScaleInput.disabled = true;
}
function installNodes(nodes){
  Model.nodes = nodes;
  Model.nodeById = new Map(nodes.map(n=>[n.id,n]));
  Model.isDrawn = false;
  View.hoveredNode = null;
  View.pinnedNode = null;
  View.hoveredElem = null;
  View.pinnedElem = null;
  invalidateSolutionAndDefScale();
}
function installElems(elems){
  Model.elems = elems;
  Model.elemById = new Map(elems.map(e=>[e.id,e]));
  Model.isDrawn = false;
  View.hoveredNode = null;
  View.pinnedNode = null;
  View.hoveredElem = null;
  View.pinnedElem = null;
  invalidateSolutionAndDefScale();
}
function crossValidate(){
  let ok = true;
  for(const e of Model.elems){
    if(!Model.nodeById.has(e.ni)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.ni}`, "log-err"); ok=false; }
    if(!Model.nodeById.has(e.nj)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.nj}`, "log-err"); ok=false; }
  }
  return ok;
}
function updateButtons(){
  const haveData = (Model.nodes.length>0 && Model.elems.length>0);
  el.btnDraw.disabled = !haveData;
  el.btnSolve.disabled = !haveData;
}

/* =========================
   Sync from textareas
   ========================= */
function syncFromTextareas({nodes=true, elems=true, announce=false} = {}){
  const newNodes = nodes ? parseNodes(el.taNodes.value || "") : null;
  const newElems = elems ? parseElems(el.taElems.value || "") : null;

  if(nodes) installNodes(newNodes);
  if(elems) installElems(newElems);

  if(announce){
    if(nodes) logLine("OK: Synced Nodes from textarea.", "log-ok");
    if(elems) logLine("OK: Synced Segments from textarea.", "log-ok");
  }

  renderSummary();
  updateButtons();
}

/* =========================
   3D Camera & Projection
   ========================= */
function project3D(x, y, z){
  // Simple perspective projection
  const cam = View.cam;
  
  // Camera position in spherical coordinates
  const camX = cam.centerX + cam.distance * Math.cos(cam.elevation) * Math.cos(cam.azimuth);
  const camY = cam.centerY + cam.distance * Math.cos(cam.elevation) * Math.sin(cam.azimuth);
  const camZ = cam.centerZ + cam.distance * Math.sin(cam.elevation);
  
  // Vector from camera to point
  const dx = x - camX;
  const dy = y - camY;
  const dz = z - camZ;
  
  // Camera basis vectors (simplified - looking at center point)
  const toCenter = {
    x: cam.centerX - camX,
    y: cam.centerY - camY,
    z: cam.centerZ - camZ
  };
  const dist = Math.sqrt(toCenter.x**2 + toCenter.y**2 + toCenter.z**2);
  const forward = {
    x: toCenter.x / dist,
    y: toCenter.y / dist,
    z: toCenter.z / dist
  };
  
  // Right vector (cross product of forward and world up)
  const worldUp = {x: 0, y: 0, z: 1};
  const right = {
    x: forward.y * worldUp.z - forward.z * worldUp.y,
    y: forward.z * worldUp.x - forward.x * worldUp.z,
    z: forward.x * worldUp.y - forward.y * worldUp.x
  };
  const rightLen = Math.sqrt(right.x**2 + right.y**2 + right.z**2);
  right.x /= rightLen; right.y /= rightLen; right.z /= rightLen;
  
  // Up vector (cross product of right and forward)
  const up = {
    x: right.y * forward.z - right.z * forward.y,
    y: right.z * forward.x - right.x * forward.z,
    z: right.x * forward.y - right.y * forward.x
  };
  
  // Project onto camera plane
  const screenX = dx * right.x + dy * right.y + dz * right.z;
  const screenY = dx * up.x + dy * up.y + dz * up.z;
  const depth = dx * forward.x + dy * forward.y + dz * forward.z;
  
  // Perspective division and screen mapping
  const scale = 600 / cam.distance; // Perspective scale
  const cx = el.canvas.width / 2;
  const cy = el.canvas.height / 2;
  
  return {
    x: cx + screenX * scale,
    y: cy - screenY * scale,
    depth: depth
  };
}

function fitView3D(nodes){
  if(!nodes || nodes.length===0) return;
  let minX=Infinity, minY=Infinity, minZ=Infinity;
  let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
  for(const n of nodes){
    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
    minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
  }
  const cx = (minX+maxX)/2, cy = (minY+maxY)/2, cz = (minZ+maxZ)/2;
  const span = Math.max(maxX-minX, maxY-minY, maxZ-minZ, 50);
  
  View.cam.centerX = cx;
  View.cam.centerY = cy;
  View.cam.centerZ = cz;
  View.cam.distance = span * 2.5;
}

/* =========================
   Drawing
   ========================= */
function clearCanvas(){
  ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,el.canvas.width,el.canvas.height);
}

function drawGrid3D(){
  const gridSize = 200;
  const gridStep = 20;
  
  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.08)";
  ctx.lineWidth = 0.5;
  
  // Draw XY grid at z=0
  for(let x = -gridSize; x <= gridSize; x += gridStep){
    const p1 = project3D(x, -gridSize, 0);
    const p2 = project3D(x, gridSize, 0);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
  for(let y = -gridSize; y <= gridSize; y += gridStep){
    const p1 = project3D(-gridSize, y, 0);
    const p2 = project3D(gridSize, y, 0);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(220,38,38,0.5)"; // X axis
  let p1 = project3D(0,0,0);
  let p2 = project3D(50,0,0);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.strokeStyle = "rgba(34,197,94,0.5)"; // Y axis
  p2 = project3D(0,50,0);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.strokeStyle = "rgba(59,130,246,0.5)"; // Z axis
  p2 = project3D(0,0,50);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.restore();
}

function draw3DArrow(x, y, z, fx, fy, fz, color="#dc2626"){
  // Draw a 3D arrow for a load vector
  const mag = Math.sqrt(fx*fx + fy*fy + fz*fz);
  if(mag < 1e-6) return;
  
  // Scale arrow length based on magnitude (heuristic)
  const maxLoad = 5000;
  const maxLength = 40;
  const arrowLen = Math.min(maxLength, maxLength * (mag / maxLoad));
  
  // Normalize direction
  const dx = (fx / mag) * arrowLen;
  const dy = (fy / mag) * arrowLen;
  const dz = (fz / mag) * arrowLen;
  
  // Draw arrow shaft (pointing FROM the load location)
  const p0 = project3D(x, y, z);
  const p1 = project3D(x - dx, y - dy, z - dz);
  
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p0.x, p0.y);
  ctx.stroke();
  
  // Draw arrowhead at the node
  const headSize = 8;
  // Create perpendicular vectors for arrowhead in screen space
  const sx = p0.x - p1.x;
  const sy = p0.y - p1.y;
  const slen = Math.sqrt(sx*sx + sy*sy);
  if(slen > 1e-6){
    const ux = sx / slen;
    const uy = sy / slen;
    const nx = -uy;
    const ny = ux;
    
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(p0.x, p0.y);
    ctx.lineTo(p0.x - headSize*ux + headSize*0.4*nx, p0.y - headSize*uy + headSize*0.4*ny);
    ctx.lineTo(p0.x - headSize*ux - headSize*0.4*nx, p0.y - headSize*uy - headSize*0.4*ny);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawBCSymbol(x, y, z, bc){
  // Draw boundary condition symbol at node
  const p = project3D(x, y, z);
  const hasTransBC = bc.ux.prescribed || bc.uy.prescribed || bc.uz.prescribed;
  const hasRotBC = bc.rx.prescribed || bc.ry.prescribed || bc.rz.prescribed;
  
  if(!hasTransBC && !hasRotBC) return; // Free node, no symbol
  
  ctx.save();
  
  // Draw triangle symbol for fixed translations
  if(hasTransBC){
    const size = 10;
    ctx.fillStyle = "rgba(59,130,246,0.7)";
    ctx.strokeStyle = "rgba(37,99,235,0.9)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y - size);
    ctx.lineTo(p.x - size*0.866, p.y + size*0.5);
    ctx.lineTo(p.x + size*0.866, p.y + size*0.5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  
  // Draw small square for rotation BCs
  if(hasRotBC){
    const size = 6;
    ctx.fillStyle = "rgba(168,85,247,0.7)";
    ctx.strokeStyle = "rgba(147,51,234,0.9)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.rect(p.x - size/2, p.y - size/2, size, size);
    ctx.fill();
    ctx.stroke();
  }
  
  ctx.restore();
}

function overlayDeflectedIfAvailable(){
  if(!Model.lastSolution) return;
  const scale = Number(el.defScale.value);
  if(!(scale > 0)) return;

  const { expanded, U } = Model.lastSolution;

  ctx.save();
  ctx.strokeStyle = "rgba(220,38,38,0.85)";
  ctx.lineWidth = 2.0;
  for(const e of expanded.elems){
    const n1 = expanded.nodes[e.ni];
    const n2 = expanded.nodes[e.nj];
    // Read from 6-DOF layout
    const ux1 = U[6*e.ni+0], uy1 = U[6*e.ni+1], uz1 = U[6*e.ni+2];
    const ux2 = U[6*e.nj+0], uy2 = U[6*e.nj+1], uz2 = U[6*e.nj+2];

    const p1 = project3D(n1.x + scale*ux1, n1.y + scale*uy1, n1.z + scale*uz1);
    const p2 = project3D(n2.x + scale*ux2, n2.y + scale*uy2, n2.z + scale*uz2);

    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  }
  ctx.restore();
}

function drawPrimary(){
  clearCanvas();
  drawGrid3D();

  // elements
  ctx.save();
  for(const e of Model.elems){
    const ni = Model.nodeById.get(e.ni);
    const nj = Model.nodeById.get(e.nj);
    if(!ni || !nj) continue;
    const a = project3D(ni.x, ni.y, ni.z);
    const b = project3D(nj.x, nj.y, nj.z);
    
    // Highlight if hovered or pinned
    const isHovered = (View.hoveredElem === e.id);
    const isPinned = (View.pinnedElem === e.id);
    const isHighlighted = isHovered || isPinned;
    
    if(isPinned){
      ctx.strokeStyle = "rgba(251,191,36,0.95)"; // Gold for pinned
      ctx.lineWidth = 4.0;
    } else if(isHovered){
      ctx.strokeStyle = "rgba(59,130,246,0.9)"; // Blue for hovered
      ctx.lineWidth = 3.5;
    } else {
      ctx.strokeStyle = "rgba(0,0,0,0.55)"; // Default
      ctx.lineWidth = 2.0;
    }
    
    ctx.beginPath(); 
    ctx.moveTo(a.x, a.y); 
    ctx.lineTo(b.x, b.y); 
    ctx.stroke();
  }
  ctx.restore();

  // BC symbols (draw before nodes so nodes appear on top)
  for(const n of Model.nodes){
    drawBCSymbol(n.x, n.y, n.z, {
      ux: n.ux, uy: n.uy, uz: n.uz,
      rx: n.rx, ry: n.ry, rz: n.rz
    });
  }

  // Load arrows
  for(const n of Model.nodes){
    const fx = n.loads.fx || 0;
    const fy = n.loads.fy || 0;
    const fz = n.loads.fz || 0;
    if(fx !== 0 || fy !== 0 || fz !== 0){
      draw3DArrow(n.x, n.y, n.z, fx, fy, fz);
    }
  }

  // nodes
  for(const n of Model.nodes){
    const p = project3D(n.x, n.y, n.z);
    ctx.save();
    
    // Highlight if hovered or pinned
    const isHovered = (View.hoveredNode === n.id);
    const isPinned = (View.pinnedNode === n.id);
    const isHighlighted = isHovered || isPinned;
    const radius = isHighlighted ? 6 : 4.2;
    
    ctx.beginPath(); 
    ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
    
    if(isPinned){
      ctx.fillStyle = "rgba(251,191,36,0.9)"; // Gold for pinned
    } else if(isHovered){
      ctx.fillStyle = "rgba(59,130,246,0.9)"; // Blue for hovered
    } else {
      ctx.fillStyle = "rgba(37,99,235,0.65)"; // Default blue
    }
    ctx.fill();
    
    if(isHighlighted){
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  overlayDeflectedIfAvailable();
}

/* =========================
   Solver (TEMPORARY: Still uses 2D beam formulation - will be updated to 3D space frame)
   ========================= */
function buildExpandedModel(nSub = 10){
  const expanded = { nodes: [], elems: [], mapPrimaryToExpandedIndex: new Map() };
  const primaryNodesSorted = [...Model.nodes].slice().sort((a,b)=>a.id-b.id);

  for(const pn of primaryNodesSorted){
    const idx = expanded.nodes.length;
    expanded.nodes.push({
      x: pn.x, y: pn.y, z: pn.z,
      label: `N${pn.id}`,
      bc: {
        ux: { prescribed: pn.ux.prescribed, value: pn.ux.value },
        uy: { prescribed: pn.uy.prescribed, value: pn.uy.value },
        uz: { prescribed: pn.uz.prescribed, value: pn.uz.value },
        rx: { prescribed: pn.rx.prescribed, value: pn.rx.value },
        ry: { prescribed: pn.ry.prescribed, value: pn.ry.value },
        rz: { prescribed: pn.rz.prescribed, value: pn.rz.value }
      },
      loads: { fx: pn.loads.fx, fy: pn.loads.fy, fz: pn.loads.fz }
    });
    expanded.mapPrimaryToExpandedIndex.set(pn.id, idx);
  }

  for(const pe of Model.elems){
    const nI = Model.nodeById.get(pe.ni);
    const nJ = Model.nodeById.get(pe.nj);
    if(!nI || !nJ) continue;

    const iExp = expanded.mapPrimaryToExpandedIndex.get(pe.ni);
    const jExp = expanded.mapPrimaryToExpandedIndex.get(pe.nj);

    const internalIdx = [];
    for(let k=1;k<nSub;k++){
      const t = k / nSub;
      const idx = expanded.nodes.length;
      expanded.nodes.push({
        x: nI.x + t*(nJ.x - nI.x),
        y: nI.y + t*(nJ.y - nI.y),
        z: nI.z + t*(nJ.z - nI.z),
        label: `S${pe.id}.${k}`,
        bc: { 
          ux:{prescribed:false,value:0}, uy:{prescribed:false,value:0}, uz:{prescribed:false,value:0},
          rx:{prescribed:false,value:0}, ry:{prescribed:false,value:0}, rz:{prescribed:false,value:0}
        },
        loads: { fx:0, fy:0, fz:0 }
      });
      internalIdx.push(idx);
    }

    const chain = [iExp, ...internalIdx, jExp];
    for(let s=0; s<nSub; s++){
      expanded.elems.push({
        ni: chain[s], nj: chain[s+1],
        E: pe.E, G: pe.G, Izz: pe.Izz, Iyy: pe.Iyy, Jyz: pe.Jyz, Ayz: pe.Ayz,
        x3: pe.x3, y3: pe.y3, z3: pe.z3,
        primaryElemId: pe.id,
        subIndex: s+1
      });
    }
  }
  return expanded;
}

function solveLinearSystemDense(A, b){
  const n = b.length;
  const M = Array.from({length:n}, (_,i)=> Float64Array.from(A[i]));
  const rhs = new Float64Array(b);

  for(let k=0;k<n;k++){
    let piv = k;
    let max = Math.abs(M[k][k]);
    for(let i=k+1;i<n;i++){
      const v = Math.abs(M[i][k]);
      if(v>max){ max=v; piv=i; }
    }
    if(max === 0 || !Number.isFinite(max)) throw new Error("Singular or ill-conditioned stiffness matrix (pivot=0).");

    if(piv !== k){
      const tmpRow = M[k]; M[k] = M[piv]; M[piv] = tmpRow;
      const tmpB = rhs[k]; rhs[k] = rhs[piv]; rhs[piv] = tmpB;
    }

    const akk = M[k][k];
    for(let i=k+1;i<n;i++){
      const factor = M[i][k] / akk;
      if(factor === 0) continue;
      rhs[i] -= factor * rhs[k];
      const Mi = M[i], Mk = M[k];
      for(let j=k;j<n;j++) Mi[j] -= factor * Mk[j];
    }
  }

  const sol = new Float64Array(n);
  for(let i=n-1;i>=0;i--){
    let sum = rhs[i];
    const Mi = M[i];
    for(let j=i+1;j<n;j++) sum -= Mi[j] * sol[j];
    sol[i] = sum / Mi[i];
  }
  return sol;
}

function elementLocalStiffness3D(E, G, Ayz, Izz, Iyy, Jyz, L){
  // 3D space frame element stiffness in local coordinates
  // 12 DOF: node i (ux, uy, uz, rx, ry, rz), node j (ux, uy, uz, rx, ry, rz)
  // Local axis: x = along element, y and z are perpendicular
  
  const EA_L = (E * Ayz) / L;
  const GJ_L = (G * Jyz) / L;
  
  // Bending about local z-axis (EIyy)
  const EIyy = E * Iyy;
  const EIyy_L3 = EIyy / (L*L*L);
  const EIyy_L2 = EIyy / (L*L);
  const EIyy_L = EIyy / L;
  
  // Bending about local y-axis (EIzz)
  const EIzz = E * Izz;
  const EIzz_L3 = EIzz / (L*L*L);
  const EIzz_L2 = EIzz / (L*L);
  const EIzz_L = EIzz / L;
  
  // Initialize 12x12 matrix
  const k = Array.from({length: 12}, () => new Float64Array(12));
  
  // Axial stiffness (DOF 0, 6)
  k[0][0] = EA_L;    k[0][6] = -EA_L;
  k[6][0] = -EA_L;   k[6][6] = EA_L;
  
  // Torsion (DOF 3, 9)
  k[3][3] = GJ_L;    k[3][9] = -GJ_L;
  k[9][3] = -GJ_L;   k[9][9] = GJ_L;
  
  // Bending in local x-y plane (y displacement, z rotation) - DOF 1, 5, 7, 11
  k[1][1] = 12*EIzz_L3;   k[1][5] = 6*EIzz_L2;    k[1][7] = -12*EIzz_L3;  k[1][11] = 6*EIzz_L2;
  k[5][1] = 6*EIzz_L2;    k[5][5] = 4*EIzz_L;     k[5][7] = -6*EIzz_L2;   k[5][11] = 2*EIzz_L;
  k[7][1] = -12*EIzz_L3;  k[7][5] = -6*EIzz_L2;   k[7][7] = 12*EIzz_L3;   k[7][11] = -6*EIzz_L2;
  k[11][1] = 6*EIzz_L2;   k[11][5] = 2*EIzz_L;    k[11][7] = -6*EIzz_L2;  k[11][11] = 4*EIzz_L;
  
  // Bending in local x-z plane (z displacement, y rotation) - DOF 2, 4, 8, 10
  k[2][2] = 12*EIyy_L3;   k[2][4] = -6*EIyy_L2;   k[2][8] = -12*EIyy_L3;  k[2][10] = -6*EIyy_L2;
  k[4][2] = -6*EIyy_L2;   k[4][4] = 4*EIyy_L;     k[4][8] = 6*EIyy_L2;    k[4][10] = 2*EIyy_L;
  k[8][2] = -12*EIyy_L3;  k[8][4] = 6*EIyy_L2;    k[8][8] = 12*EIyy_L3;   k[8][10] = 6*EIyy_L2;
  k[10][2] = -6*EIyy_L2;  k[10][4] = 2*EIyy_L;    k[10][8] = 6*EIyy_L2;   k[10][10] = 4*EIyy_L;
  
  return k;
}

function build3DTransformationMatrix(ni, nj, x3, y3, z3){
  // Build 12x12 transformation matrix from local to global coordinates
  // Local x-axis: from ni to nj
  // Local y and z axes: defined by orientation point (x3, y3, z3)
  
  const dx = nj.x - ni.x;
  const dy = nj.y - ni.y;
  const dz = nj.z - ni.z;
  const L = Math.sqrt(dx*dx + dy*dy + dz*dz);
  
  if(L < 1e-10) throw new Error("Zero-length element");
  
  // Local x-axis (unit vector along element)
  const xx = dx / L;
  const xy = dy / L;
  const xz = dz / L;
  
  // Vector from node i to orientation point
  const vx = x3 - ni.x;
  const vy = y3 - ni.y;
  const vz = z3 - ni.z;
  
  // Project v onto local x-axis
  const dot = vx*xx + vy*xy + vz*xz;
  
  // Component of v perpendicular to x-axis (in x-z local plane)
  const vzx = vx - dot*xx;
  const vzy = vy - dot*xy;
  const vzz = vz - dot*xz;
  
  const vzLen = Math.sqrt(vzx*vzx + vzy*vzy + vzz*vzz);
  
  if(vzLen < 1e-10) throw new Error("Orientation point is collinear with element axis");
  
  // Local z-axis (unit vector)
  const zx = vzx / vzLen;
  const zy = vzy / vzLen;
  const zz = vzz / vzLen;
  
  // Local y-axis: y = z Ã— x (cross product)
  const yx = zy*xz - zz*xy;
  const yy = zz*xx - zx*xz;
  const yz = zx*xy - zy*xx;
  
  // Build 3x3 rotation matrix
  const R = [
    [xx, xy, xz],
    [yx, yy, yz],
    [zx, zy, zz]
  ];
  
  // Build 12x12 transformation matrix (block diagonal)
  const T = Array.from({length: 12}, () => new Float64Array(12));
  
  for(let block = 0; block < 4; block++){
    const offset = block * 3;
    for(let i = 0; i < 3; i++){
      for(let j = 0; j < 3; j++){
        T[offset + i][offset + j] = R[i][j];
      }
    }
  }
  
  return T;
}

function solveStaticExpanded(expanded){
  // Full 3D space frame solver with 6 DOF per node
  const N = expanded.nodes.length;
  const ndof = 6*N; // 6 DOF per node (ux, uy, uz, rx, ry, rz)

  const K = Array.from({length: ndof}, ()=> new Float64Array(ndof));
  const F = new Float64Array(ndof);
  const U = new Float64Array(ndof);

  // Apply loads (6 DOF per node)
  for(let i=0;i<N;i++){
    const n = expanded.nodes[i];
    F[6*i+0] += n.loads.fx;
    F[6*i+1] += n.loads.fy;
    F[6*i+2] += n.loads.fz;
    // Moment loads would go in F[6*i+3], F[6*i+4], F[6*i+5]
  }

  // Assemble global stiffness matrix
  for(const e of expanded.elems){
    const n1 = expanded.nodes[e.ni];
    const n2 = expanded.nodes[e.nj];
    const dx = n2.x-n1.x, dy = n2.y-n1.y, dz = n2.z-n1.z;
    const L = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if(!(L>0)) throw new Error("Zero-length element detected in expanded mesh.");
    
    // Local stiffness matrix (12x12)
    const kLocal = elementLocalStiffness3D(e.E, e.G, e.Ayz, e.Izz, e.Iyy, e.Jyz, L);
    
    // Transformation matrix (12x12)
    const T = build3DTransformationMatrix(n1, n2, e.x3, e.y3, e.z3);
    
    // Transform to global: kg = T^T * kLocal * T
    // First: tmp = kLocal * T
    const tmp = Array.from({length:12}, ()=> new Float64Array(12));
    for(let i=0;i<12;i++){
      for(let j=0;j<12;j++){
        let sum = 0;
        for(let m=0;m<12;m++) sum += kLocal[i][m] * T[m][j];
        tmp[i][j] = sum;
      }
    }
    
    // Second: kg = T^T * tmp
    const kg = Array.from({length:12}, ()=> new Float64Array(12));
    for(let i=0;i<12;i++){
      for(let j=0;j<12;j++){
        let sum = 0;
        for(let m=0;m<12;m++) sum += T[m][i] * tmp[m][j];
        kg[i][j] = sum;
      }
    }

    // Assemble into global K
    const dofs = [
      6*e.ni+0, 6*e.ni+1, 6*e.ni+2, 6*e.ni+3, 6*e.ni+4, 6*e.ni+5,
      6*e.nj+0, 6*e.nj+1, 6*e.nj+2, 6*e.nj+3, 6*e.nj+4, 6*e.nj+5
    ];
    for(let a=0;a<12;a++){
      const Irow = dofs[a];
      const Krow = K[Irow];
      for(let b=0;b<12;b++) Krow[dofs[b]] += kg[a][b];
    }
  }

  // Apply boundary conditions (6 DOF per node)
  const fixed=[], fixedVal=[], free=[];
  for(let i=0;i<N;i++){
    const bc = expanded.nodes[i].bc;
    const d0=6*i+0, d1=6*i+1, d2=6*i+2, d3=6*i+3, d4=6*i+4, d5=6*i+5;
    if(bc.ux.prescribed){ fixed.push(d0); fixedVal.push(bc.ux.value); } else free.push(d0);
    if(bc.uy.prescribed){ fixed.push(d1); fixedVal.push(bc.uy.value); } else free.push(d1);
    if(bc.uz.prescribed){ fixed.push(d2); fixedVal.push(bc.uz.value); } else free.push(d2);
    if(bc.rx.prescribed){ fixed.push(d3); fixedVal.push(bc.rx.value); } else free.push(d3);
    if(bc.ry.prescribed){ fixed.push(d4); fixedVal.push(bc.ry.value); } else free.push(d4);
    if(bc.rz.prescribed){ fixed.push(d5); fixedVal.push(bc.rz.value); } else free.push(d5);
  }
  if(free.length===0) throw new Error("All DOFs are prescribed; nothing to solve.");

  const nF=free.length, nC=fixed.length;
  const Rf=new Float64Array(nF);
  for(let a=0;a<nF;a++){
    const I=free[a];
    let rhs=F[I];
    for(let b=0;b<nC;b++){
      const J=fixed[b];
      rhs -= K[I][J]*fixedVal[b];
    }
    Rf[a]=rhs;
  }
  const Kff=Array.from({length:nF}, ()=> new Float64Array(nF));
  for(let a=0;a<nF;a++){
    const I=free[a];
    for(let b=0;b<nF;b++){
      const J=free[b];
      Kff[a][b]=K[I][J];
    }
  }
  
  const Uf=solveLinearSystemDense(Kff,Rf);

  for(let b=0;b<nC;b++) U[fixed[b]]=fixedVal[b];
  for(let a=0;a<nF;a++) U[free[a]]=Uf[a];

  return { U, F, K, meta:{N,ndof,nFree:nF,nFixed:nC} };
}

function summarizeDisplacements(expanded, U){
  let maxMag = { val:-Infinity, label:"" };
  let minMag = { val:+Infinity, label:"" };
  for(let i=0;i<expanded.nodes.length;i++){
    // Read from 6-DOF layout
    const ux = U[6*i+0], uy = U[6*i+1], uz = U[6*i+2];
    const mag = Math.hypot(ux, uy, uz);
    const lab = expanded.nodes[i].label || `idx${i}`;
    if(mag > maxMag.val) maxMag = { val:mag, label:lab };
    if(mag < minMag.val) minMag = { val:mag, label:lab };
  }
  return { maxMag, minMag };
}

function elementEndForcesLocal(expanded, e, U){
  // Recover element end forces in local coordinates
  const n1 = expanded.nodes[e.ni];
  const n2 = expanded.nodes[e.nj];
  const dx = n2.x-n1.x, dy = n2.y-n1.y, dz = n2.z-n1.z;
  const L = Math.sqrt(dx*dx + dy*dy + dz*dz);

  // Get global displacements (12 DOF)
  const uG = new Float64Array(12);
  for(let i=0; i<6; i++){
    uG[i] = U[6*e.ni + i];
    uG[i+6] = U[6*e.nj + i];
  }

  // Transform to local coordinates
  const T = build3DTransformationMatrix(n1, n2, e.x3, e.y3, e.z3);
  const uL = new Float64Array(12);
  for(let i=0; i<12; i++){
    let sum = 0;
    for(let j=0; j<12; j++){
      sum += T[j][i] * uG[j];
    }
    uL[i] = sum;
  }

  // Compute local forces: fL = kL * uL
  const kL = elementLocalStiffness3D(e.E, e.G, e.Ayz, e.Izz, e.Iyy, e.Jyz, L);
  const fL = new Float64Array(12);
  for(let i=0; i<12; i++){
    let sum = 0;
    for(let j=0; j<12; j++){
      sum += kL[i][j] * uL[j];
    }
    fL[i] = sum;
  }
  
  return { fL, L };
}

function calculateElementStresses(expanded, elemIndex, U){
  // Calculate stresses at a specific point along an expanded element
  // This function is called for each subsegment to build the stress profile
  const e = expanded.elems[elemIndex];
  const {fL, L} = elementEndForcesLocal(expanded, e, U);
  
  // Extract end forces (local coordinates)
  // Node i: [Fx_i, Fy_i, Fz_i, Mx_i, My_i, Mz_i]
  // Node j: [Fx_j, Fy_j, Fz_j, Mx_j, My_j, Mz_j]
  const forces = {
    i: {
      Fx: fL[0], Fy: fL[1], Fz: fL[2],
      Mx: fL[3], My: fL[4], Mz: fL[5]
    },
    j: {
      Fx: fL[6], Fy: fL[7], Fz: fL[8],
      Mx: fL[9], My: fL[10], Mz: fL[11]
    }
  };
  
  // FORCE CLAMPING (Sanitize tiny values to zero)
  const sanitize = (v) => (Math.abs(v) < 1e-9 ? 0.0 : v);
  forces.i.Fx = sanitize(forces.i.Fx); forces.i.Fy = sanitize(forces.i.Fy); forces.i.Fz = sanitize(forces.i.Fz);
  forces.i.Mx = sanitize(forces.i.Mx); forces.i.My = sanitize(forces.i.My); forces.i.Mz = sanitize(forces.i.Mz);
  forces.j.Fx = sanitize(forces.j.Fx); forces.j.Fy = sanitize(forces.j.Fy); forces.j.Fz = sanitize(forces.j.Fz);
  forces.j.Mx = sanitize(forces.j.Mx); forces.j.My = sanitize(forces.j.My); forces.j.Mz = sanitize(forces.j.Mz);

  // AXIAL STRESS - CONSTANT along element (no distributed load)
  // Using node i value (should equal -node j value for equilibrium)
  const N = forces.i.Fx; // Axial force (tension positive)
  const sigma_axial = N / e.Ayz;
  
  // SHEAR FORCES - CONSTANT along element (no distributed load)
  // Using node i values
  const Vy = forces.i.Fy; // Shear force in local y
  const Vz = forces.i.Fz; // Shear force in local z
  
  // Average shear stress (simplified - could use shape factor for more accuracy)
  const tau_y = Math.abs(Vy) / e.Ayz;
  const tau_z = Math.abs(Vz) / e.Ayz;
  const tau_shear = Math.sqrt(tau_y*tau_y + tau_z*tau_z);
  
  // TORSION - CONSTANT along element
  const Mx = forces.i.Mx; // Torsional moment
  // Approximate distance to extreme fiber for torsion
  const c_torsion = Math.sqrt(Math.max(e.Iyy, e.Izz) / e.Ayz);
  const tau_torsion = Math.abs(Mx) * c_torsion / e.Jyz;
  
  // BENDING MOMENTS - These are the values AT NODE i
  // For stress variation along element, caller must interpolate
  const My_i = forces.i.My; // Moment about local y-axis at node i
  const Mz_i = forces.i.Mz; // Moment about local z-axis at node i
  const My_j = forces.j.My; // Moment about local y-axis at node j
  const Mz_j = forces.j.Mz; // Moment about local z-axis at node j
  
  // Estimate distance to extreme fiber (rectangular section assumption)
  // For more accuracy, would need actual section dimensions
  const c_y = Math.sqrt(e.Iyy / e.Ayz); // Distance in y-direction
  const c_z = Math.sqrt(e.Izz / e.Ayz); // Distance in z-direction
  
  // Bending stresses at node i
  // FIXED: My bends in X-Z plane, resisted by Iyy. Distance is c_z.
  const sigma_bend_y_i = Math.abs(My_i) * c_z / e.Iyy; 
  // FIXED: Mz bends in X-Y plane, resisted by Izz. Distance is c_y.
  const sigma_bend_z_i = Math.abs(Mz_i) * c_y / e.Izz; 
  
  // Bending stresses at node j
  const sigma_bend_y_j = Math.abs(My_j) * c_z / e.Iyy;
  const sigma_bend_z_j = Math.abs(Mz_j) * c_y / e.Izz;
  
  // Combined stresses at node i (extreme fibers)
  const sigma_max_i = sigma_axial + sigma_bend_y_i + sigma_bend_z_i;
  const sigma_min_i = sigma_axial - sigma_bend_y_i - sigma_bend_z_i;
  
  // Combined stresses at node j
  const sigma_max_j = sigma_axial + sigma_bend_y_j + sigma_bend_z_j;
  const sigma_min_j = sigma_axial - sigma_bend_y_j - sigma_bend_z_j;
  
  return {
    forces,
    moments: {
      My_i, Mz_i, My_j, Mz_j
    },
    stresses: {
      axial: sigma_axial,           // CONSTANT
      shear: tau_shear,             // CONSTANT
      torsion: tau_torsion,         // CONSTANT
      bending_i: { 
        My: sigma_bend_y_i,         // At node i
        Mz: sigma_bend_z_i 
      },
      bending_j: { 
        My: sigma_bend_y_j,         // At node j
        Mz: sigma_bend_z_j 
      },
      combined_max_i: sigma_max_i,  // At node i
      combined_min_i: sigma_min_i,
      combined_max_j: sigma_max_j,  // At node j
      combined_min_j: sigma_min_j
    },
    length: L,
    sectionProperties: { c_y, c_z, Ayz: e.Ayz, Izz: e.Izz, Iyy: e.Iyy }
  };
}

function summarizeStresses(expanded, U){
  // Summary of max/min stresses across all elements
  let maxSig = { val:-Infinity, at:"" };
  let minSig = { val:+Infinity, at:"" };
  
  for(let i=0; i<expanded.elems.length; i++){
    const result = calculateElementStresses(expanded, i, U);
    const e = expanded.elems[i];
    
    const localMax = Math.max(
      result.stresses.combined_max_i,
      result.stresses.combined_max_j
    );
    const localMin = Math.min(
      result.stresses.combined_min_i,
      result.stresses.combined_min_j
    );
    
    const where = `seg ${e.primaryElemId}, sub ${e.subIndex}`;
    if(localMax > maxSig.val) maxSig = { val:localMax, at:where };
    if(localMin < minSig.val) minSig = { val:localMin, at:where };
  }
  
  return { maxSig, minSig };
}

function verifyElementForces(elemId){
  // Diagnostic function to verify internal forces are consistent across subsegments
  if(!Model.lastSolution) return null;
  
  const subElems = Model.lastSolution.expanded.elems.filter(e => e.primaryElemId === elemId);
  if(subElems.length === 0) return null;
  
  const forceData = [];
  
  for(let i = 0; i < subElems.length; i++){
    const e = subElems[i];
    const elemIdx = Model.lastSolution.expanded.elems.indexOf(e);
    const {fL} = elementEndForcesLocal(Model.lastSolution.expanded, elemIdx, Model.lastSolution.U);
    
    forceData.push({
      subseg: i + 1,
      Fx_i: fL[0],  // Axial force at node i
      Fx_j: fL[6],  // Axial force at node j (should be -Fx_i)
      Fy_i: fL[1],  // Shear y at node i
      Fy_j: fL[7],  // Shear y at node j (should be -Fy_i)
      Fz_i: fL[2],  // Shear z at node i
      Fz_j: fL[8],  // Shear z at node j (should be -Fz_i)
      Mx_i: fL[3],  // Torsion at node i
      Mx_j: fL[9],  // Torsion at node j (should be -Mx_i)
      My_i: fL[4],  // Moment y at node i
      My_j: fL[10], // Moment y at node j
      Mz_i: fL[5],  // Moment z at node i
      Mz_j: fL[11]  // Moment z at node j
    });
  }
  
  // Check consistency
  const axialValues = forceData.map(d => d.Fx_i);
  const shearYValues = forceData.map(d => d.Fy_i);
  const shearZValues = forceData.map(d => d.Fz_i);
  const torsionValues = forceData.map(d => d.Mx_i);
  
  const axialRange = Math.max(...axialValues) - Math.min(...axialValues);
  const shearYRange = Math.max(...shearYValues) - Math.min(...shearYValues);
  const shearZRange = Math.max(...shearZValues) - Math.min(...shearZValues);
  const torsionRange = Math.max(...torsionValues) - Math.min(...torsionValues);
  
  return {
    forceData,
    consistency: {
      axial: { range: axialRange, isConstant: axialRange < 1e-3 },
      shearY: { range: shearYRange, isConstant: shearYRange < 1e-3 },
      shearZ: { range: shearZRange, isConstant: shearZRange < 1e-3 },
      torsion: { range: torsionRange, isConstant: torsionRange < 1e-3 }
    }
  };
}

function displayElementAnalysis(elemId, viewMode){
  // Display analysis for a primary segment with selectable view modes
  if(!Model.lastSolution){
    el.stressContent.innerHTML = '<div style="color:var(--muted); font-size:12px; text-align:center; padding:20px;">Run Static Solve first to analyze stresses.</div>';
    el.stressViewSelector.disabled = true;
    return;
  }
  
  const elem = Model.elemById.get(elemId);
  if(!elem){
    el.stressContent.innerHTML = '<div style="color:var(--err); font-size:12px; text-align:center; padding:20px;">Element not found.</div>';
    el.stressViewSelector.disabled = true;
    return;
  }
  
  // Enable view selector
  el.stressViewSelector.disabled = false;
  
  // Find all expanded sub-elements for this primary element
  const subElems = Model.lastSolution.expanded.elems.filter(e => e.primaryElemId === elemId);
  
  if(subElems.length === 0){
    el.stressContent.innerHTML = '<div style="color:var(--err); font-size:12px; text-align:center; padding:20px;">No subsegments found.</div>';
    return;
  }
  
  // We fetch data from the START of the first subsegment and the END of the last subsegment.
  const firstSubElemIdx = Model.lastSolution.expanded.elems.indexOf(subElems[0]);
  const lastSubElemIdx = Model.lastSolution.expanded.elems.indexOf(subElems[subElems.length-1]);
  
  // Forces at Start of Beam (from First Subsegment Node i)
  const forcesStart = calculateElementStresses(Model.lastSolution.expanded, firstSubElemIdx, Model.lastSolution.U);
  
  // Forces at End of Beam (from Last Subsegment Node j)
  const forcesEnd = calculateElementStresses(Model.lastSolution.expanded, lastSubElemIdx, Model.lastSolution.U);
  
  // Get primary element properties
  const ni_primary = Model.nodeById.get(elem.ni);
  const nj_primary = Model.nodeById.get(elem.nj);
  const dx = nj_primary.x - ni_primary.x;
  const dy = nj_primary.y - ni_primary.y;
  const dz = nj_primary.z - ni_primary.z;
  const L_primary = Math.sqrt(dx*dx + dy*dy + dz*dz);
  
  // Extract CONSTANT internal forces (these don't change along element)
  const N = forcesStart.forces.i.Fx;  // Axial force - CONSTANT
  const Vy = forcesStart.forces.i.Fy; // Shear y - CONSTANT
  const Vz = forcesStart.forces.i.Fz; // Shear z - CONSTANT
  const Mx = forcesStart.forces.i.Mx; // Torsion - CONSTANT
  
  // Extract end moments (Linearly Interpolated between Start and End of Beam)
  const My_start = forcesStart.forces.i.My;
  const Mz_start = forcesStart.forces.i.Mz;
  const My_end = forcesEnd.forces.j.My; // Taking force from node j of last segment
  const Mz_end = forcesEnd.forces.j.Mz; // Taking force from node j of last segment
  
  // Section properties (from primary element)
  const Ayz = elem.Ayz;
  const Izz = elem.Izz;
  const Iyy = elem.Iyy;
  const Jyz = elem.Jyz;
  const c_y = forcesStart.sectionProperties.c_y;
  const c_z = forcesStart.sectionProperties.c_z;
  
  // CONSTANT stresses (independent of position)
  const sigma_axial = N / Ayz;
  const tau_y = Math.abs(Vy) / Ayz;
  const tau_z = Math.abs(Vz) / Ayz;
  const tau_shear = Math.sqrt(tau_y*tau_y + tau_z*tau_z);
  const c_torsion = Math.sqrt(Math.max(Iyy, Izz) / Ayz);
  const tau_torsion = Math.abs(Mx) * c_torsion / Jyz;
  
  // Build stress profile at different positions along element
  const numPoints = 11; // Calculate at 0%, 10%, 20%, ..., 100%
  const stressProfile = [];
  
  for(let i = 0; i < numPoints; i++){
    const xi = i / (numPoints - 1); // Position from 0 to 1
    
    // Linearly interpolate moments over TOTAL length
    const My_xi = My_start + xi * (My_end - My_start);
    const Mz_xi = Mz_start + xi * (Mz_end - Mz_start);
    
    // Bending stresses at this position
    // FIXED: My resisted by Iyy, distance c_z
    const sigma_bend_My = Math.abs(My_xi) * c_z / Iyy;
    // FIXED: Mz resisted by Izz, distance c_y
    const sigma_bend_Mz = Math.abs(Mz_xi) * c_y / Izz;
    
    // Combined stresses (extreme fibers)
    const sigma_max = sigma_axial + sigma_bend_My + sigma_bend_Mz;
    const sigma_min = sigma_axial - sigma_bend_My - sigma_bend_Mz;
    
    stressProfile.push({
      position: xi,
      My: My_xi,
      Mz: Mz_xi,
      sigma_axial: sigma_axial,       // CONSTANT
      sigma_bend_My: sigma_bend_My,
      sigma_bend_Mz: sigma_bend_Mz,
      sigma_max: sigma_max,
      sigma_min: sigma_min,
      tau_shear: tau_shear,           // CONSTANT
      tau_torsion: tau_torsion        // CONSTANT
    });
  }
  
  // Get the mode to display
  const mode = viewMode || el.stressViewSelector.value;
  
  let html = `<div class="stressLabel">Segment ${elemId}: Node ${elem.ni} â†’ ${elem.nj}</div>`;
  html += `<div class="stressValue" style="margin-bottom:10px;">Length: ${L_primary.toFixed(2)}</div>`;
  
  if(mode === 'table'){
    html += buildStressTableCorrected(stressProfile);
  } else if(mode === 'moment'){
    html += buildMomentDiagramsCorrected(stressProfile, elem);
  } else if(mode === 'shear'){
    html += buildShearDiagramsCorrected(Vy, Vz);
  } else if(mode === 'combined'){
    html += buildCombinedStressDiagramCorrected(stressProfile, elem);
  }
  
  el.stressContent.innerHTML = html;
}

function buildStressTableCorrected(stressProfile){
  // Table with corrected constant/varying values
  
  let html = '<table class="stressTable"><thead><tr>';
  html += '<th>Position</th><th>Axial*<br>(Ïƒ)</th><th>Bend My<br>(Ïƒ)</th><th>Bend Mz<br>(Ïƒ)</th>';
  html += '<th>Combined<br>Max (Ïƒ)</th><th>Combined<br>Min (Ïƒ)</th><th>Shear*<br>(Ï„)</th><th>Torsion*<br>(Ï„)</th>';
  html += '</tr></thead><tbody>';
  
  stressProfile.forEach((sp) => {
    const posPercent = (sp.position * 100).toFixed(0);
    
    html += '<tr>';
    html += `<td>${posPercent}%</td>`;
    html += `<td>${sp.sigma_axial.toFixed(2)}</td>`;
    html += `<td>${sp.sigma_bend_My.toFixed(2)}</td>`;
    html += `<td>${sp.sigma_bend_Mz.toFixed(2)}</td>`;
    html += `<td>${sp.sigma_max.toFixed(2)}</td>`;
    html += `<td>${sp.sigma_min.toFixed(2)}</td>`;
    html += `<td>${sp.tau_shear.toFixed(2)}</td>`;
    html += `<td>${sp.tau_torsion.toFixed(2)}</td>`;
    html += '</tr>';
  });
  
  html += '</tbody></table>';
  
  // Summary
  const sigma_axial = stressProfile[0].sigma_axial;
  const tau_shear = stressProfile[0].tau_shear;
  const tau_torsion = stressProfile[0].tau_torsion;
  const maxCombined = Math.max(...stressProfile.map(sp => sp.sigma_max));
  const minCombined = Math.min(...stressProfile.map(sp => sp.sigma_min));
  
  html += '<div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--line); font-size:11px;">';
  html += '<div class="stressLabel">Summary (* = constant values):</div>';
  html += `<div class="stressValue">Axial*: ${sigma_axial.toFixed(2)} | Shear*: ${tau_shear.toFixed(2)} | Torsion*: ${tau_torsion.toFixed(2)}</div>`;
  html += `<div class="stressValue">Combined Envelope: Max=${maxCombined.toFixed(2)}, Min=${minCombined.toFixed(2)}</div>`;
  html += '</div>';
  
  return html;
}

function buildMomentDiagramsCorrected(stressProfile, elem){
  // Plot My and Mz along element length
  const width = el.stressContent.clientWidth - 40;
  const height = 200;
  const margin = {top: 20, right: 60, bottom: 40, left: 60};
  const plotWidth = width - margin.left - margin.right;
  const plotHeight = height - margin.top - margin.bottom;
  
  // Extract moment data
  const positions = stressProfile.map(sp => sp.position);
  const My_values = stressProfile.map(sp => sp.My);
  const Mz_values = stressProfile.map(sp => sp.Mz);
  
  const My_max = Math.max(...My_values.map(Math.abs));
  const Mz_max = Math.max(...Mz_values.map(Math.abs));
  const M_max = Math.max(My_max, Mz_max) || 1;
  
  let html = '<div style="margin-bottom:10px; font-size:11px;">';
  html += '<div class="stressLabel">Bending Moment Diagrams (Local Coordinates)</div>';
  html += '<div class="stressValue">My = moment about local y-axis (causes bending in x-z plane)</div>';
  html += '<div class="stressValue">Mz = moment about local z-axis (causes bending in x-y plane)</div>';
  html += '</div>';
  
  html += `<svg width="${width}" height="${height}" style="border:1px solid var(--line); background:#fff;">`;
  
  const yScale = plotHeight / 2 / M_max;
  const yZero = margin.top + plotHeight / 2;
  
  // Axes
  html += `<line x1="${margin.left}" y1="${yZero}" x2="${margin.left + plotWidth}" y2="${yZero}" stroke="#ccc" stroke-width="1"/>`;
  html += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotHeight}" stroke="#666" stroke-width="1"/>`;
  
  // Plot My line
  let pathMy = `M ${margin.left} ${yZero - My_values[0] * yScale}`;
  for(let i = 1; i < positions.length; i++){
    const x = margin.left + positions[i] * plotWidth;
    const y = yZero - My_values[i] * yScale;
    pathMy += ` L ${x} ${y}`;
  }
  html += `<path d="${pathMy}" fill="none" stroke="#dc2626" stroke-width="2"/>`;
  
  // Plot Mz line
  let pathMz = `M ${margin.left} ${yZero - Mz_values[0] * yScale}`;
  for(let i = 1; i < positions.length; i++){
    const x = margin.left + positions[i] * plotWidth;
    const y = yZero - Mz_values[i] * yScale;
    pathMz += ` L ${x} ${y}`;
  }
  html += `<path d="${pathMz}" fill="none" stroke="#2563eb" stroke-width="2"/>`;
  
  // Labels
  html += `<text x="${margin.left + plotWidth/2}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#666">Position along element</text>`;
  html += `<text x="${15}" y="${margin.top + plotHeight/2}" text-anchor="middle" font-size="11" fill="#666" transform="rotate(-90, 15, ${margin.top + plotHeight/2})">Moment</text>`;
  
  // Legend
  html += `<line x1="${width - 150}" y1="${margin.top + 10}" x2="${width - 130}" y2="${margin.top + 10}" stroke="#dc2626" stroke-width="2"/>`;
  html += `<text x="${width - 125}" y="${margin.top + 14}" font-size="10" fill="#666">My</text>`;
  html += `<line x1="${width - 150}" y1="${margin.top + 25}" x2="${width - 130}" y2="${margin.top + 25}" stroke="#2563eb" stroke-width="2"/>`;
  html += `<text x="${width - 125}" y="${margin.top + 29}" font-size="10" fill="#666">Mz</text>`;
  
  html += '</svg>';
  
  // Values
  html += '<div style="margin-top:8px; font-size:11px;">';
  html += `<div class="stressValue">My range: ${Math.min(...My_values).toFixed(1)} to ${Math.max(...My_values).toFixed(1)}</div>`;
  html += `<div class="stressValue">Mz range: ${Math.min(...Mz_values).toFixed(1)} to ${Math.max(...Mz_values).toFixed(1)}</div>`;
  html += '</div>';
  
  return html;
}

function buildShearDiagramsCorrected(Vy, Vz){
  // Plot constant shear forces
  const width = el.stressContent.clientWidth - 40;
  const height = 150;
  const margin = {top: 20, right: 60, bottom: 40, left: 60};
  const plotWidth = width - margin.left - margin.right;
  const plotHeight = height - margin.top - margin.bottom;
  
  let html = '<div style="margin-bottom:10px; font-size:11px;">';
  html += '<div class="stressLabel">Shear Force Diagrams (Local Coordinates)</div>';
  html += '<div class="stressValue">Vy and Vz are CONSTANT (no distributed load)</div>';
  html += '</div>';
  
  html += `<svg width="${width}" height="${height}" style="border:1px solid var(--line); background:#fff;">`;
  
  const V_max = Math.max(Math.abs(Vy), Math.abs(Vz)) || 1;
  const yScale = plotHeight / 2 / V_max;
  const yZero = margin.top + plotHeight / 2;
  
  // Axes
  html += `<line x1="${margin.left}" y1="${yZero}" x2="${margin.left + plotWidth}" y2="${yZero}" stroke="#ccc" stroke-width="1"/>`;
  html += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotHeight}" stroke="#666" stroke-width="1"/>`;
  
  // Constant Vy line
  const yVy = yZero - Vy * yScale;
  html += `<line x1="${margin.left}" y1="${yVy}" x2="${margin.left + plotWidth}" y2="${yVy}" stroke="#dc2626" stroke-width="2"/>`;
  
  // Constant Vz line
  const yVz = yZero - Vz * yScale;
  html += `<line x1="${margin.left}" y1="${yVz}" x2="${margin.left + plotWidth}" y2="${yVz}" stroke="#2563eb" stroke-width="2"/>`;
  
  // Labels
  html += `<text x="${margin.left + plotWidth/2}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#666">Position along element</text>`;
  html += `<text x="${15}" y="${margin.top + plotHeight/2}" text-anchor="middle" font-size="11" fill="#666" transform="rotate(-90, 15, ${margin.top + plotHeight/2})">Shear Force</text>`;
  
  // Legend
  html += `<line x1="${width - 150}" y1="${margin.top + 10}" x2="${width - 130}" y2="${margin.top + 10}" stroke="#dc2626" stroke-width="2"/>`;
  html += `<text x="${width - 125}" y="${margin.top + 14}" font-size="10" fill="#666">Vy = ${Vy.toFixed(2)}</text>`;
  html += `<line x1="${width - 150}" y1="${margin.top + 25}" x2="${width - 130}" y2="${margin.top + 25}" stroke="#2563eb" stroke-width="2"/>`;
  html += `<text x="${width - 125}" y="${margin.top + 29}" font-size="10" fill="#666">Vz = ${Vz.toFixed(2)}</text>`;
  
  html += '</svg>';
  
  return html;
}

function buildCombinedStressDiagramCorrected(stressProfile, elem){
  // Plot combined max and min stress along element
  const width = el.stressContent.clientWidth - 40;
  const height = 200;
  const margin = {top: 20, right: 60, bottom: 40, left: 60};
  const plotWidth = width - margin.left - margin.right;
  const plotHeight = height - margin.top - margin.bottom;
  
  const positions = stressProfile.map(sp => sp.position);
  const maxStress = stressProfile.map(sp => sp.sigma_max);
  const minStress = stressProfile.map(sp => sp.sigma_min);
  
  const globalMax = Math.max(...maxStress);
  const globalMin = Math.min(...minStress);
  const range = Math.max(Math.abs(globalMax), Math.abs(globalMin)) || 1;
  
  let html = '<div style="margin-bottom:10px; font-size:11px;">';
  html += '<div class="stressLabel">Combined Normal Stress Envelope</div>';
  html += '<div class="stressValue">Ïƒ = Ïƒ_axial + Ïƒ_bending (at extreme fibers)</div>';
  html += '</div>';
  
  html += `<svg width="${width}" height="${height}" style="border:1px solid var(--line); background:#fff;">`;
  
  const yScale = plotHeight / 2 / range;
  const yZero = margin.top + plotHeight / 2;
  
  // Axes
  html += `<line x1="${margin.left}" y1="${yZero}" x2="${margin.left + plotWidth}" y2="${yZero}" stroke="#ccc" stroke-width="1"/>`;
  html += `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotHeight}" stroke="#666" stroke-width="1"/>`;
  
  // Plot max stress (upper envelope)
  let pathMax = `M ${margin.left} ${yZero - maxStress[0] * yScale}`;
  for(let i = 1; i < positions.length; i++){
    const x = margin.left + positions[i] * plotWidth;
    const y = yZero - maxStress[i] * yScale;
    pathMax += ` L ${x} ${y}`;
  }
  html += `<path d="${pathMax}" fill="none" stroke="#dc2626" stroke-width="2"/>`;
  
  // Plot min stress (lower envelope)
  let pathMin = `M ${margin.left} ${yZero - minStress[0] * yScale}`;
  for(let i = 1; i < positions.length; i++){
    const x = margin.left + positions[i] * plotWidth;
    const y = yZero - minStress[i] * yScale;
    pathMin += ` L ${x} ${y}`;
  }
  html += `<path d="${pathMin}" fill="none" stroke="#2563eb" stroke-width="2"/>`;
  
  // Fill between curves
  const fillPath = pathMax + ' ' + pathMin.split(' ').reverse().join(' ') + ' Z';
  html += `<path d="${fillPath}" fill="rgba(147, 51, 234, 0.1)" stroke="none"/>`;
  
  // Labels
  html += `<text x="${margin.left + plotWidth/2}" y="${height - 5}" text-anchor="middle" font-size="11" fill="#666">Position along element</text>`;
  html += `<text x="${15}" y="${margin.top + plotHeight/2}" text-anchor="middle" font-size="11" fill="#666" transform="rotate(-90, 15, ${margin.top + plotHeight/2})">Stress (Ïƒ)</text>`;
  
  // Legend
  html += `<line x1="${width - 180}" y1="${margin.top + 10}" x2="${width - 160}" y2="${margin.top + 10}" stroke="#dc2626" stroke-width="2"/>`;
  html += `<text x="${width - 155}" y="${margin.top + 14}" font-size="10" fill="#666">Max = ${globalMax.toFixed(2)}</text>`;
  html += `<line x1="${width - 180}" y1="${margin.top + 25}" x2="${width - 160}" y2="${margin.top + 25}" stroke="#2563eb" stroke-width="2"/>`;
  html += `<text x="${width - 155}" y="${margin.top + 29}" font-size="10" fill="#666">Min = ${globalMin.toFixed(2)}</text>`;
  
  html += '</svg>';
  
  return html;
}

/* =========================
   UI wiring
   ========================= */
el.btnImportNodes.addEventListener('click', ()=> el.fileNodes.click());
el.btnImportElems.addEventListener('click', ()=> el.fileElems.click());

el.fileNodes.addEventListener('change', async ()=>{
  const f = el.fileNodes.files?.[0];
  if(!f) return;
  logClear(); setStatus("Reading nodes...");
  try{
    el.taNodes.value = await f.text();
    syncFromTextareas({nodes:true, elems:false, announce:true});
    logLine(`OK: Loaded nodes file "${f.name}" into textarea.`, "log-ok");
  }catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle"); el.fileNodes.value="";
});

el.fileElems.addEventListener('change', async ()=>{
  const f = el.fileElems.files?.[0];
  if(!f) return;
  logClear(); setStatus("Reading segments...");
  try{
    el.taElems.value = await f.text();
    syncFromTextareas({nodes:false, elems:true, announce:true});
    logLine(`OK: Loaded segments file "${f.name}" into textarea.`, "log-ok");
  }catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle"); el.fileElems.value="";
});

el.btnParseNodes.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing nodes...");
  try{ syncFromTextareas({nodes:true, elems:false, announce:true}); }
  catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle");
});
el.btnParseElems.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing segments...");
  try{ syncFromTextareas({nodes:false, elems:true, announce:true}); }
  catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle");
});

el.btnResetNodes.addEventListener('click', ()=>{
  logClear();
  el.taNodes.value = DEFAULT_NODES_TEXT;
  try{
    syncFromTextareas({nodes:true, elems:false, announce:false});
    logLine("OK: Nodes reset to defaults and installed.", "log-ok");
  }catch(err){
    logLine(`ERROR resetting nodes: ${err.message}`, "log-err");
  }
  setStatus("Idle");
});
el.btnResetElems.addEventListener('click', ()=>{
  logClear();
  el.taElems.value = DEFAULT_ELEMS_TEXT;
  try{
    syncFromTextareas({nodes:false, elems:true, announce:false});
    logLine("OK: Segments reset to defaults and installed.", "log-ok");
  }catch(err){
    logLine(`ERROR resetting segments: ${err.message}`, "log-err");
  }
  setStatus("Idle");
});

el.btnDraw.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing + validating...");
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Fix input");
    return;
  }

  if(!crossValidate()){ setStatus("Fix input"); return; }

  View.isInteractive = true;
  fitView3D(Model.nodes);
  Model.isDrawn = true;
  drawPrimary();
  setStatus("Interactive");
  logLine("OK: Frame drawn in 3D viewport.", "log-ok");
});

el.btnSolve.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing + validating...");
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Fix input");
    return;
  }

  if(!crossValidate()){ setStatus("Fix input"); return; }

  try{
    setStatus("Expanding mesh...");
    const expanded = buildExpandedModel(10);

    setStatus("Solving...");
    const sol = solveStaticExpanded(expanded);

    setStatus("Post-processing...");
    const disp = summarizeDisplacements(expanded, sol.U);
    const stress = summarizeStresses(expanded, sol.U);

    Model.lastSolution = { expanded, U: sol.U, F: sol.F, meta: sol.meta, disp, stress };
    renderSummary();

    el.defScale.disabled = false;
    el.defScaleInput.disabled = false;
    el.defScale.value = 0;
    el.defScaleInput.value = 0;

    logLine(`OK: Static solve complete. DOF ${sol.meta.ndof} (free ${sol.meta.nFree}, fixed ${sol.meta.nFixed}).`, "log-ok");
    logLine(`Displacements (expanded): Max |u| = ${disp.maxMag.val.toFixed(4)} at ${disp.maxMag.label}`, "log-ok");
    logLine(`Displacements (expanded): Min |u| = ${disp.minMag.val.toFixed(4)} at ${disp.minMag.label}`, "log-ok");
    logLine(`Stresses: Max sigma = ${stress.maxSig.val.toFixed(2)} at ${stress.maxSig.at}`, "log-ok");
    logLine(`Stresses: Min sigma = ${stress.minSig.val.toFixed(2)} at ${stress.minSig.at}`, "log-ok");

    View.isInteractive = true;
    fitView3D(Model.nodes);
    Model.isDrawn = true;
    drawPrimary();
    setStatus("Solved (use deflection scale slider)");
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Solve failed");
  }
});

el.defScale.addEventListener('input', ()=>{
  const val = Number(el.defScale.value);
  el.defScaleInput.value = val;
  if(Model.isDrawn) drawPrimary();
});

el.defScaleInput.addEventListener('input', ()=>{
  const val = Number(el.defScaleInput.value);
  const max = Number(el.defScale.max);
  // Clamp to slider range
  const clamped = Math.max(0, Math.min(max, val));
  el.defScale.value = clamped;
  el.defScaleInput.value = clamped;
  if(Model.isDrawn) drawPrimary();
});

el.btnSetMaxScale.addEventListener('click', ()=>{
  const newMax = Number(el.defScaleMaxInput.value);
  if(!Number.isFinite(newMax) || newMax <= 0){
    logLine("ERROR: Slider max must be a positive number", "log-err");
    return;
  }
  el.defScale.max = newMax;
  el.defScaleMax.textContent = newMax;
  logLine(`OK: Deflection slider max set to ${newMax}`, "log-ok");
});

el.stressViewSelector.addEventListener('change', ()=>{
  if(View.selectedSegmentForAnalysis !== null){
    displayElementAnalysis(View.selectedSegmentForAnalysis);
  }
});

/* =========================
   3D Camera Controls
   ========================= */
function canvasPointFromEvent(evt){
  const r = el.canvas.getBoundingClientRect();
  return {
    x:(evt.clientX-r.left)*(el.canvas.width/r.width),
    y:(evt.clientY-r.top)*(el.canvas.height/r.height)
  };
}

function findNodeAtScreenPoint(sx, sy, tolerance = 10){
  // Find which node (if any) is near the screen point
  for(const n of Model.nodes){
    const p = project3D(n.x, n.y, n.z);
    const dist = Math.sqrt((p.x - sx)**2 + (p.y - sy)**2);
    if(dist <= tolerance) return n;
  }
  return null;
}

function findElemAtScreenPoint(sx, sy, tolerance = 8){
  // Find which element (if any) is near the screen point
  // Check distance from point to line segment in screen space
  for(const e of Model.elems){
    const ni = Model.nodeById.get(e.ni);
    const nj = Model.nodeById.get(e.nj);
    if(!ni || !nj) continue;
    
    const p1 = project3D(ni.x, ni.y, ni.z);
    const p2 = project3D(nj.x, nj.y, nj.z);
    
    // Vector from p1 to p2
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len2 = dx*dx + dy*dy;
    
    if(len2 < 1e-6) continue; // Skip zero-length segments
    
    // Parameter t of closest point on line segment
    let t = ((sx - p1.x)*dx + (sy - p1.y)*dy) / len2;
    t = Math.max(0, Math.min(1, t)); // Clamp to segment
    
    // Closest point on segment
    const closestX = p1.x + t*dx;
    const closestY = p1.y + t*dy;
    
    // Distance from mouse to closest point
    const dist = Math.sqrt((sx - closestX)**2 + (sy - closestY)**2);
    
    if(dist <= tolerance) return e;
  }
  return null;
}

function formatBCTooltip(node){
  // Format boundary condition tooltip with loads
  const parts = [];
  
  const ux = node.ux.prescribed ? `Ux=${node.ux.value}` : "Ux=free";
  const uy = node.uy.prescribed ? `Uy=${node.uy.value}` : "Uy=free";
  const uz = node.uz.prescribed ? `Uz=${node.uz.value}` : "Uz=free";
  const rx = node.rx.prescribed ? `Rx=${node.rx.value}` : "Rx=free";
  const ry = node.ry.prescribed ? `Ry=${node.ry.value}` : "Ry=free";
  const rz = node.rz.prescribed ? `Rz=${node.rz.value}` : "Rz=free";
  
  let tooltip = `Node ${node.id}: ${ux}, ${uy}, ${uz}, ${rx}, ${ry}, ${rz}`;
  
  // Add loads if any are non-zero
  const fx = node.loads.fx || 0;
  const fy = node.loads.fy || 0;
  const fz = node.loads.fz || 0;
  
  if(fx !== 0 || fy !== 0 || fz !== 0){
    const loadParts = [];
    if(fx !== 0) loadParts.push(`Fx=${fx}`);
    if(fy !== 0) loadParts.push(`Fy=${fy}`);
    if(fz !== 0) loadParts.push(`Fz=${fz}`);
    tooltip += ` | Loads: ${loadParts.join(', ')}`;
  }
  
  return tooltip;
}

function formatElemTooltip(elem){
  // Format element properties tooltip
  const ni = Model.nodeById.get(elem.ni);
  const nj = Model.nodeById.get(elem.nj);
  
  let tooltip = `Segment ${elem.id}: Node ${elem.ni}â†’${elem.nj}`;
  tooltip += ` | E=${elem.E.toExponential(2)}, G=${elem.G.toExponential(2)}`;
  tooltip += ` | Izz=${elem.Izz}, Iyy=${elem.Iyy}, Jyz=${elem.Jyz}, Ayz=${elem.Ayz}`;
  tooltip += ` | Orient: (${elem.x3}, ${elem.y3}, ${elem.z3})`;
  
  // Calculate length
  if(ni && nj){
    const dx = nj.x - ni.x;
    const dy = nj.y - ni.y;
    const dz = nj.z - ni.z;
    const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
    tooltip += ` | Length=${len.toFixed(2)}`;
  }
  
  return tooltip;
}

function updateTooltip(){
  // Update the tooltip display based on pinned or hovered node/element
  // Priority: pinned element > pinned node > hovered element > hovered node
  
  if(View.pinnedElem !== null){
    const elem = Model.elemById.get(View.pinnedElem);
    if(elem){
      const tooltip = formatElemTooltip(elem);
      el.selInfo.textContent = tooltip + " (pinned - click elsewhere to unpin)";
      el.selInfo.style.color = "var(--text)";
      return;
    }
  }
  
  if(View.pinnedNode !== null){
    const node = Model.nodeById.get(View.pinnedNode);
    if(node){
      const tooltip = formatBCTooltip(node);
      el.selInfo.textContent = tooltip + " (pinned - click elsewhere to unpin)";
      el.selInfo.style.color = "var(--text)";
      return;
    }
  }
  
  if(View.hoveredElem !== null){
    const elem = Model.elemById.get(View.hoveredElem);
    if(elem){
      el.selInfo.textContent = formatElemTooltip(elem);
      el.selInfo.style.color = "var(--text)";
      return;
    }
  }
  
  if(View.hoveredNode !== null){
    const node = Model.nodeById.get(View.hoveredNode);
    if(node){
      el.selInfo.textContent = formatBCTooltip(node);
      el.selInfo.style.color = "var(--text)";
      return;
    }
  }
  
  el.selInfo.textContent = "";
}

el.canvas.addEventListener('mousedown',(evt)=>{
  if(!View.isInteractive) return;
  evt.preventDefault();
  
  const p = canvasPointFromEvent(evt);
  
  // Check if clicking on a node or element (only for left click)
  if(evt.button === 0){
    // Nodes have priority over elements
    const clickedNode = findNodeAtScreenPoint(p.x, p.y);
    const clickedElem = clickedNode ? null : findElemAtScreenPoint(p.x, p.y);
    
    if(clickedNode){
      // Toggle pin on this node
      if(View.pinnedNode === clickedNode.id){
        View.pinnedNode = null; // Unpin if already pinned
      } else {
        View.pinnedNode = clickedNode.id; // Pin this node
        View.pinnedElem = null; // Unpin any element
      }
      updateTooltip();
      if(Model.isDrawn) drawPrimary();
      return; // Don't start drag if clicking a node
    } else if(clickedElem){
      // Toggle pin on this element
      if(View.pinnedElem === clickedElem.id){
        View.pinnedElem = null; // Unpin if already pinned
      } else {
        View.pinnedElem = clickedElem.id; // Pin this element
        View.pinnedNode = null; // Unpin any node
        // Display analysis for this element
        View.selectedSegmentForAnalysis = clickedElem.id;
        displayElementAnalysis(clickedElem.id);
      }
      updateTooltip();
      if(Model.isDrawn) drawPrimary();
      return; // Don't start drag if clicking an element
    } else {
      // Clicked empty space, unpin everything
      if(View.pinnedNode !== null || View.pinnedElem !== null){
        View.pinnedNode = null;
        View.pinnedElem = null;
        updateTooltip();
        if(Model.isDrawn) drawPrimary();
      }
    }
  }
  
  // Start drag operation
  View.dragging = true;
  View.dragButton = evt.button;
  View.dragStart.x = p.x;
  View.dragStart.y = p.y;
  View.dragStart.azimuth = View.cam.azimuth;
  View.dragStart.elevation = View.cam.elevation;
  View.dragStart.centerX = View.cam.centerX;
  View.dragStart.centerY = View.cam.centerY;
  View.dragStart.centerZ = View.cam.centerZ;
});

window.addEventListener('mouseup',()=>{ View.dragging=false; });

window.addEventListener('mousemove',(evt)=>{
  if(!View.isInteractive) return;
  
  const p = canvasPointFromEvent(evt);
  View.mousePos.x = p.x;
  View.mousePos.y = p.y;
  
  if(View.dragging){
    const dx = p.x - View.dragStart.x;
    const dy = p.y - View.dragStart.y;

    if(View.dragButton === 0){ // Left button - orbit
      View.cam.azimuth = View.dragStart.azimuth + dx * 0.01;
      View.cam.elevation = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, View.dragStart.elevation - dy * 0.01));
    } else if(View.dragButton === 2){ // Right button - pan
      const panSpeed = View.cam.distance * 0.002;
      const right = {
        x: Math.sin(View.cam.azimuth),
        y: -Math.cos(View.cam.azimuth)
      };
      const up = {
        x: Math.cos(View.cam.azimuth) * Math.sin(View.cam.elevation),
        y: Math.sin(View.cam.azimuth) * Math.sin(View.cam.elevation),
        z: Math.cos(View.cam.elevation)
      };
      
      View.cam.centerX = View.dragStart.centerX - dx * panSpeed * right.x + dy * panSpeed * up.x;
      View.cam.centerY = View.dragStart.centerY - dx * panSpeed * right.y + dy * panSpeed * up.y;
      View.cam.centerZ = View.dragStart.centerZ + dy * panSpeed * up.z;
    }
    
    if(Model.isDrawn) drawPrimary();
  } else {
    // Check for node hover when not dragging (nodes have priority over elements)
    const hoveredNode = findNodeAtScreenPoint(p.x, p.y);
    const hoveredElem = hoveredNode ? null : findElemAtScreenPoint(p.x, p.y);
    
    const newNodeID = hoveredNode ? hoveredNode.id : null;
    const newElemID = hoveredElem ? hoveredElem.id : null;
    
    if(newNodeID !== View.hoveredNode || newElemID !== View.hoveredElem){
      View.hoveredNode = newNodeID;
      View.hoveredElem = newElemID;
      updateTooltip();
      if(Model.isDrawn) drawPrimary();
    }
  }
});

el.canvas.addEventListener('wheel',(evt)=>{
  if(!View.isInteractive) return;
  evt.preventDefault();
  const zoomFactor = Math.exp(-evt.deltaY * 0.001);
  View.cam.distance = Math.max(10, Math.min(10000, View.cam.distance * zoomFactor));
  if(Model.isDrawn) drawPrimary();
},{passive:false});

el.canvas.addEventListener('contextmenu',(evt)=>{
  evt.preventDefault(); // Prevent context menu on right-click
});

/* =========================
   Startup
   ========================= */
function init(){
  clearCanvas();
  el.taNodes.value = DEFAULT_NODES_TEXT;
  el.taElems.value = DEFAULT_ELEMS_TEXT;

  logClear();
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
    logLine("Loaded defaults into model. Edit text and click Solve; changes take effect immediately.", "log-ok");
  }catch(err){
    logLine(`ERROR loading defaults: ${err.message}`, "log-err");
  }
  setStatus("Idle");
}
init();
</script>
</body>
</html>
