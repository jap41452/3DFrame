<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>3D Frame Analysis (v2: Clean Data Model - Static/Modal Solver)</title>
<style>
  :root{
    --bg:#ffffff;
    --panel:#f5f6f8;
    --panel2:#ffffff;
    --line:#d7dbe3;
    --text:#111827;
    --muted:#5b6472;
    --accent:#2563eb;
    --warn:#b45309;
    --err:#b91c1c;
    --ok:#166534;
  }
  html,body{height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  #app{height:100%; display:flex; align-items:flex-start; gap:10px; padding:10px; box-sizing:border-box;}
  #ui{width:375px; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:10px; box-sizing:border-box; overflow-y:auto;}
  #viewportWrap{flex:1; min-width:600px; height:600px; background:var(--panel2); border:1px solid var(--line); border-radius:10px; padding:8px; box-sizing:border-box; display:flex; flex-direction:column; gap:6px;}
  #canvas{width:100%; height:100%; background:#ffffff; border:1px solid var(--line); border-radius:8px; display:block;}
  h3{margin:0 0 8px 0; font-size:14px; font-weight:700;}
  .sectionTitle{font-size:12px; font-weight:700; margin:10px 0 6px; color:#1f2937;}
  button{width:100%; padding:8px 10px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text); font-weight:700; cursor:pointer;}
  button:hover{border-color:#b9c3d6;}
  button:disabled{opacity:0.55; cursor:not-allowed;}
  .hint{font-size:12px; color:var(--muted); line-height:1.25; margin:8px 0;}
  .small{font-size:12px; color:var(--muted);}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #cfd6e2; background:#ffffff; font-size:12px; color:var(--muted);}
  #summary{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;}
  #log{margin-top:10px; padding:8px; background:#ffffff; border:1px solid var(--line); border-radius:8px; height:190px; overflow:auto; font-size:12px; line-height:1.25; white-space:pre-wrap;}
  .log-warn{color:var(--warn);} .log-err{color:var(--err);} .log-ok{color:var(--ok);}
  #vpBar{display:flex; justify-content:space-between; align-items:center; font-size:12px; color:var(--muted); padding:0 2px;}
  #selInfo{font-size:12px; color:var(--muted); min-height:16px;}
  textarea{width:100%; box-sizing:border-box; min-height:72px; max-height:140px; resize:vertical; padding:8px; border-radius:8px; border:1px solid #cfd6e2; background:#ffffff; color:var(--text);
           font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:11px; line-height:1.2;}
  .btnRow{display:flex; gap:8px;} .btnRow button{width:50%;}
  .mini{padding:7px 8px; font-size:12px;}
  .sep{height:10px;}
  .sliderWrap{margin-top:8px;}
  input[type="range"]{width:100%;}
  .kv{display:flex; justify-content:space-between; gap:10px; font-size:12px; color:var(--muted);}
</style>
</head>

<body>
<div id="app">
  <div id="ui">
    <h3>Frame Definition</h3>

    <div class="sectionTitle">Nodes</div>
    <button id="btnImportNodes">Load Nodes File</button>
    <input id="fileNodes" type="file" accept=".txt,.tsv,.csv" style="display:none" />
    <div class="hint small">Paste from Excel (tab-delimited) or CSV. Header row optional.</div>
    <textarea id="taNodes" placeholder="Paste node table: node  x  y  z  delX  delY  delZ  thetaXX  thetaYY  thetaZZ  Fx  Fy  Fz"></textarea>
    <div class="btnRow">
      <button id="btnParseNodes" class="mini">Use Nodes</button>
      <button id="btnResetNodes" class="mini">Reset</button>
    </div>

    <div class="sectionTitle">Segments</div>
    <button id="btnImportElems">Load Segments File</button>
    <input id="fileElems" type="file" accept=".txt,.tsv,.csv" style="display:none" />
    <div class="hint small">elem  ni  nj  E  G  Izz  Iyy  Jyz  Ayz  x3  y3  z3</div>
    <textarea id="taElems" placeholder="Paste segment table: elem  ni  nj  E  G  Izz  Iyy  Jyz  Ayz  x3  y3  z3"></textarea>
    <div class="btnRow">
      <button id="btnParseElems" class="mini">Use Segments</button>
      <button id="btnResetElems" class="mini">Reset</button>
    </div>

    <div class="sep"></div>

    <button id="btnDraw" disabled>Draw / Edit Frame</button>
    <div class="sep"></div>
    <button id="btnSolve" disabled>Static Solve (10 subsegments/segment)</button>

    <div class="sliderWrap">
      <div class="kv">
        <div>Deflection scale</div>
        <div id="defScaleLabel">0</div>
      </div>
      <input id="defScale" type="range" min="0" max="200" step="1" value="0" disabled />
      <div class="hint small">After solve, increase scale to view the overlaid deflected shape.</div>
    </div>

    <div class="hint">Viewport: Left-drag = orbit, Right-drag = pan, Wheel = zoom.</div>
    <div id="summary"></div>
    <div id="log"></div>
  </div>

  <div id="viewportWrap">
    <div id="vpBar">
      <div>3D Viewport</div>
      <div id="status" class="small">Idle</div>
    </div>
    <canvas id="canvas"></canvas>
    <div id="selInfo"></div>
  </div>
</div>

<script>
/* =========================
   3D FRAME ANALYSIS v2
   =========================
   DEVELOPMENT STATUS:
   ✓ Data model updated to full 3D (x,y,z coords, 6 DOF per node, 3D element properties)
   ✓ Material type (brittle/ductile) removed - simple static & modes solver
   ✓ 3D viewport with orbit/pan/zoom camera controls
   
   TODO (Next Steps):
   - Implement 3D space frame element stiffness (12x12, using E, G, Ayz, Izz, Iyy, Jyz)
   - Implement local coordinate transformation using x3,y3,z3 orientation point
   - Update solver to use 6 DOF per node (ux,uy,uz, rx,ry,rz)
   - Add modal analysis (eigenvalue solver for natural frequencies & mode shapes)
   - Update stress recovery for 3D elements
   ========================= */

/* =========================
   Defaults
   ========================= */
const DEFAULT_NODES_TEXT =
`1\t0\t0\t0\t0\t0\t0
2\t0\t96\t0\t\t\t\t\t\t\t1000\t0\t0
3\t96\t96\t0
4\t96\t0\t0\t0\t0\t0`;

const DEFAULT_ELEMS_TEXT =
`1\t2\t12000000\t4600000\t10.7\t10.7\t21.4\t8\t0\t0\t1
2\t3\t12000000\t4600000\t10.7\t10.7\t21.4\t8\t0\t0\t1
3\t4\t12000000\t4600000\t10.7\t10.7\t21.4\t8\t0\t0\t1
2\t4\t12000000\t4600000\t10.7\t10.7\t21.4\t8\t0\t0\t1`;

/* =========================
   Model
   ========================= */
const Model = {
  nodes: [],
  elems: [],
  nodeById: new Map(),
  elemById: new Map(),
  lastSolution: null,
  isDrawn: false
};

const View = {
  cam: {
    distance: 300,
    azimuth: 45 * Math.PI / 180,   // horizontal rotation
    elevation: 30 * Math.PI / 180, // vertical rotation
    centerX: 48,
    centerY: 48,
    centerZ: 0
  },
  isInteractive: false,
  dragging: false,
  dragButton: 0,
  dragStart: {x:0, y:0, azimuth:0, elevation:0, centerX:0, centerY:0, centerZ:0}
};

/* =========================
   DOM
   ========================= */
const el = {
  btnImportNodes: document.getElementById('btnImportNodes'),
  btnImportElems: document.getElementById('btnImportElems'),
  btnDraw: document.getElementById('btnDraw'),
  btnSolve: document.getElementById('btnSolve'),
  fileNodes: document.getElementById('fileNodes'),
  fileElems: document.getElementById('fileElems'),
  taNodes: document.getElementById('taNodes'),
  taElems: document.getElementById('taElems'),
  btnParseNodes: document.getElementById('btnParseNodes'),
  btnParseElems: document.getElementById('btnParseElems'),
  btnResetNodes: document.getElementById('btnResetNodes'),
  btnResetElems: document.getElementById('btnResetElems'),
  log: document.getElementById('log'),
  summary: document.getElementById('summary'),
  canvas: document.getElementById('canvas'),
  status: document.getElementById('status'),
  selInfo: document.getElementById('selInfo'),
  defScale: document.getElementById('defScale'),
  defScaleLabel: document.getElementById('defScaleLabel')
};
const ctx = el.canvas.getContext('2d');

/* =========================
   Canvas sizing
   ========================= */
function resizeCanvas(){
  const rect = el.canvas.getBoundingClientRect();
  el.canvas.width = rect.width;
  el.canvas.height = rect.height;
  if(Model.isDrawn) drawPrimary();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* =========================
   Logging
   ========================= */
function logClear(){ el.log.textContent = ""; }
function logLine(msg, cls=null){
  const d = document.createElement('div');
  d.textContent = msg;
  if(cls) d.className = cls;
  el.log.appendChild(d);
  el.log.scrollTop = el.log.scrollHeight;
}
function setStatus(msg){ el.status.textContent = msg; }
function badge(text){
  const b = document.createElement('span');
  b.className = 'badge';
  b.textContent = text;
  return b;
}
function renderSummary(){
  const n = Model.nodes.length;
  const m = Model.elems.length;
  const prescribed = Model.nodes.reduce((acc,nd)=>acc +
    (nd.ux.prescribed?1:0)+(nd.uy.prescribed?1:0)+(nd.uz.prescribed?1:0)+
    (nd.rx.prescribed?1:0)+(nd.ry.prescribed?1:0)+(nd.rz.prescribed?1:0), 0);
  const loads = Model.nodes.reduce((acc,nd)=>acc + 
    ((nd.loads.fx||0)!==0?1:0)+((nd.loads.fy||0)!==0?1:0)+((nd.loads.fz||0)!==0?1:0), 0);

  el.summary.innerHTML = "";
  el.summary.appendChild(badge(`Nodes: ${n}`));
  el.summary.appendChild(badge(`Segments: ${m}`));
  el.summary.appendChild(badge(`Prescribed DOF: ${prescribed}`));
  el.summary.appendChild(badge(`Load terms: ${loads}`));

  if(Model.lastSolution){
    const exN = Model.lastSolution.expanded.nodes.length;
    const exE = Model.lastSolution.expanded.elems.length;
    el.summary.appendChild(badge(`Expanded: ${exN} nodes, ${exE} segs`));
  }
}

/* =========================
   Parsing utilities
   ========================= */
function isBlankToken(t){
  if(t==null) return true;
  const s = String(t).trim();
  return s === "" || s === "." || /^na$/i.test(s);
}
function toNumberOrNull(t){
  if(isBlankToken(t)) return null;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function toNumberOrZero(t){
  if(isBlankToken(t)) return 0;
  const v = Number(String(t).trim());
  return Number.isFinite(v) ? v : NaN;
}
function splitLine(line){
  if(line.includes("\t")) return line.split("\t");
  if(line.includes(","))  return line.split(",");
  return line.trim().split(/\s+/);
}
function isCommentOrBlank(line){
  const s = line.trim();
  return s === "" || s.startsWith("#") || s.startsWith("//");
}
function detectHeader(tokens){
  return tokens.some(t => /[A-Za-z]/.test(String(t)));
}
function normalizeHeader(h){
  return String(h).trim().toLowerCase()
    .replace(/\s+/g,'')
    .replace(/_/g,'')
    .replace(/-/g,'');
}

/* =========================
   Parse nodes: node x y z delX delY delZ thetaXX thetaYY thetaZZ Fx Fy Fz
   ========================= */
function parseNodes(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No node data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const nodes = [];
  const seen = new Set();
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];
    const nodeTok = get(toks,"node",0) ?? get(toks,"nodeno",0) ?? toks[0];
    const id = parseInt(String(nodeTok).trim(), 10);
    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid node number "${nodeTok}"`);
    if(seen.has(id)) throw new Error(`Row ${r+1}: duplicate node number ${id}`);
    seen.add(id);

    const x = toNumberOrNull(get(toks,"x",1));
    const y = toNumberOrNull(get(toks,"y",2));
    const z = toNumberOrNull(get(toks,"z",3));
    if(!Number.isFinite(x)) throw new Error(`Row ${r+1}: invalid X`);
    if(!Number.isFinite(y)) throw new Error(`Row ${r+1}: invalid Y`);
    if(!Number.isFinite(z)) throw new Error(`Row ${r+1}: invalid Z`);

    const dx = toNumberOrNull(get(toks,"delx",4) ?? get(toks,"dx",4));
    const dy = toNumberOrNull(get(toks,"dely",5) ?? get(toks,"dy",5));
    const dz = toNumberOrNull(get(toks,"delz",6) ?? get(toks,"dz",6));
    
    const thx = toNumberOrNull(get(toks,"thetaxx",7) ?? get(toks,"thxx",7) ?? get(toks,"rx",7));
    const thy = toNumberOrNull(get(toks,"thetayy",8) ?? get(toks,"thyy",8) ?? get(toks,"ry",8));
    const thz = toNumberOrNull(get(toks,"thetazz",9) ?? get(toks,"thzz",9) ?? get(toks,"rz",9));

    const fx = toNumberOrZero(get(toks,"fx",10));
    const fy = toNumberOrZero(get(toks,"fy",11));
    const fz = toNumberOrZero(get(toks,"fz",12));

    if(!Number.isFinite(fx)) throw new Error(`Row ${r+1}: invalid Fx`);
    if(!Number.isFinite(fy)) throw new Error(`Row ${r+1}: invalid Fy`);
    if(!Number.isFinite(fz)) throw new Error(`Row ${r+1}: invalid Fz`);
    if(dx!==null && !Number.isFinite(dx)) throw new Error(`Row ${r+1}: invalid delX`);
    if(dy!==null && !Number.isFinite(dy)) throw new Error(`Row ${r+1}: invalid delY`);
    if(dz!==null && !Number.isFinite(dz)) throw new Error(`Row ${r+1}: invalid delZ`);
    if(thx!==null && !Number.isFinite(thx)) throw new Error(`Row ${r+1}: invalid thetaXX`);
    if(thy!==null && !Number.isFinite(thy)) throw new Error(`Row ${r+1}: invalid thetaYY`);
    if(thz!==null && !Number.isFinite(thz)) throw new Error(`Row ${r+1}: invalid thetaZZ`);

    nodes.push({
      id, x, y, z,
      ux: { prescribed: dx!==null, value: dx ?? 0 },
      uy: { prescribed: dy!==null, value: dy ?? 0 },
      uz: { prescribed: dz!==null, value: dz ?? 0 },
      rx: { prescribed: thx!==null, value: thx ?? 0 },
      ry: { prescribed: thy!==null, value: thy ?? 0 },
      rz: { prescribed: thz!==null, value: thz ?? 0 },
      loads: { fx, fy, fz }
    });
  }
  return nodes;
}

/* =========================
   Parse elems: elem ni nj E G Izz Iyy Jyz Ayz x3 y3 z3
   ========================= */
function parseElems(text){
  const lines = text.split(/\r?\n/);
  const rows = [];
  for(const line of lines){
    if(isCommentOrBlank(line)) continue;
    const toks = splitLine(line).map(s=>String(s).trim());
    if(toks.length) rows.push(toks);
  }
  if(rows.length === 0) throw new Error("No segment data rows found.");

  let headerMap = null, startIdx = 0;
  if(detectHeader(rows[0])){
    headerMap = new Map();
    rows[0].forEach((h,i)=>headerMap.set(normalizeHeader(h), i));
    startIdx = 1;
  }
  const get = (toks, name, idxFallback) => {
    if(headerMap){
      const i = headerMap.get(normalizeHeader(name));
      return (i==null) ? null : toks[i];
    }
    return toks[idxFallback];
  };

  const elems = [];
  for(let r=startIdx; r<rows.length; r++){
    const toks = rows[r];

    const elemTok = get(toks,"elem",0) ?? get(toks,"element",0) ?? toks[0];
    const niTok = get(toks,"ni",1) ?? get(toks,"nodei",1) ?? toks[1];
    const njTok = get(toks,"nj",2) ?? get(toks,"nodej",2) ?? toks[2];
    
    const id = parseInt(String(elemTok).trim(), 10);
    const ni = parseInt(String(niTok).trim(),10);
    const nj = parseInt(String(njTok).trim(),10);
    
    if(!Number.isFinite(id)) throw new Error(`Row ${r+1}: invalid element number`);
    if(!Number.isFinite(ni) || !Number.isFinite(nj)) throw new Error(`Row ${r+1}: invalid node i/j`);
    if(ni === nj) throw new Error(`Row ${r+1}: ni and nj cannot be the same (${ni})`);

    const E = toNumberOrNull(get(toks,"e",3));
    const G = toNumberOrNull(get(toks,"g",4));
    const Izz = toNumberOrNull(get(toks,"izz",5));
    const Iyy = toNumberOrNull(get(toks,"iyy",6));
    const Jyz = toNumberOrNull(get(toks,"jyz",7) ?? get(toks,"j",7));
    const Ayz = toNumberOrNull(get(toks,"ayz",8) ?? get(toks,"a",8));
    
    const x3 = toNumberOrNull(get(toks,"x3",9));
    const y3 = toNumberOrNull(get(toks,"y3",10));
    const z3 = toNumberOrNull(get(toks,"z3",11));

    if(!Number.isFinite(E) || E<=0) throw new Error(`Row ${r+1}: invalid E (must be > 0)`);
    if(!Number.isFinite(G) || G<=0) throw new Error(`Row ${r+1}: invalid G (must be > 0)`);
    if(!Number.isFinite(Izz) || Izz<=0) throw new Error(`Row ${r+1}: invalid Izz (must be > 0)`);
    if(!Number.isFinite(Iyy) || Iyy<=0) throw new Error(`Row ${r+1}: invalid Iyy (must be > 0)`);
    if(!Number.isFinite(Jyz) || Jyz<=0) throw new Error(`Row ${r+1}: invalid Jyz (must be > 0)`);
    if(!Number.isFinite(Ayz) || Ayz<=0) throw new Error(`Row ${r+1}: invalid Ayz (must be > 0)`);
    if(!Number.isFinite(x3)) throw new Error(`Row ${r+1}: invalid x3`);
    if(!Number.isFinite(y3)) throw new Error(`Row ${r+1}: invalid y3`);
    if(!Number.isFinite(z3)) throw new Error(`Row ${r+1}: invalid z3`);

    elems.push({ id, ni, nj, E, G, Izz, Iyy, Jyz, Ayz, x3, y3, z3 });
  }
  return elems;
}

/* =========================
   Install / invalidate
   ========================= */
function invalidateSolutionAndDefScale(){
  Model.lastSolution = null;
  el.defScale.value = 0;
  el.defScale.disabled = true;
  el.defScaleLabel.textContent = "0";
}
function installNodes(nodes){
  Model.nodes = nodes;
  Model.nodeById = new Map(nodes.map(n=>[n.id,n]));
  Model.isDrawn = false;
  invalidateSolutionAndDefScale();
}
function installElems(elems){
  Model.elems = elems;
  Model.elemById = new Map(elems.map(e=>[e.id,e]));
  Model.isDrawn = false;
  invalidateSolutionAndDefScale();
}
function crossValidate(){
  let ok = true;
  for(const e of Model.elems){
    if(!Model.nodeById.has(e.ni)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.ni}`, "log-err"); ok=false; }
    if(!Model.nodeById.has(e.nj)){ logLine(`ERROR: Segment ${e.id} references missing node ${e.nj}`, "log-err"); ok=false; }
  }
  return ok;
}
function updateButtons(){
  const haveData = (Model.nodes.length>0 && Model.elems.length>0);
  el.btnDraw.disabled = !haveData;
  el.btnSolve.disabled = !haveData;
}

/* =========================
   Sync from textareas
   ========================= */
function syncFromTextareas({nodes=true, elems=true, announce=false} = {}){
  const newNodes = nodes ? parseNodes(el.taNodes.value || "") : null;
  const newElems = elems ? parseElems(el.taElems.value || "") : null;

  if(nodes) installNodes(newNodes);
  if(elems) installElems(newElems);

  if(announce){
    if(nodes) logLine("OK: Synced Nodes from textarea.", "log-ok");
    if(elems) logLine("OK: Synced Segments from textarea.", "log-ok");
  }

  renderSummary();
  updateButtons();
}

/* =========================
   3D Camera & Projection
   ========================= */
function project3D(x, y, z){
  // Simple perspective projection
  const cam = View.cam;
  
  // Camera position in spherical coordinates
  const camX = cam.centerX + cam.distance * Math.cos(cam.elevation) * Math.cos(cam.azimuth);
  const camY = cam.centerY + cam.distance * Math.cos(cam.elevation) * Math.sin(cam.azimuth);
  const camZ = cam.centerZ + cam.distance * Math.sin(cam.elevation);
  
  // Vector from camera to point
  const dx = x - camX;
  const dy = y - camY;
  const dz = z - camZ;
  
  // Camera basis vectors (simplified - looking at center point)
  const toCenter = {
    x: cam.centerX - camX,
    y: cam.centerY - camY,
    z: cam.centerZ - camZ
  };
  const dist = Math.sqrt(toCenter.x**2 + toCenter.y**2 + toCenter.z**2);
  const forward = {
    x: toCenter.x / dist,
    y: toCenter.y / dist,
    z: toCenter.z / dist
  };
  
  // Right vector (cross product of forward and world up)
  const worldUp = {x: 0, y: 0, z: 1};
  const right = {
    x: forward.y * worldUp.z - forward.z * worldUp.y,
    y: forward.z * worldUp.x - forward.x * worldUp.z,
    z: forward.x * worldUp.y - forward.y * worldUp.x
  };
  const rightLen = Math.sqrt(right.x**2 + right.y**2 + right.z**2);
  right.x /= rightLen; right.y /= rightLen; right.z /= rightLen;
  
  // Up vector (cross product of right and forward)
  const up = {
    x: right.y * forward.z - right.z * forward.y,
    y: right.z * forward.x - right.x * forward.z,
    z: right.x * forward.y - right.y * forward.x
  };
  
  // Project onto camera plane
  const screenX = dx * right.x + dy * right.y + dz * right.z;
  const screenY = dx * up.x + dy * up.y + dz * up.z;
  const depth = dx * forward.x + dy * forward.y + dz * forward.z;
  
  // Perspective division and screen mapping
  const scale = 600 / cam.distance; // Perspective scale
  const cx = el.canvas.width / 2;
  const cy = el.canvas.height / 2;
  
  return {
    x: cx + screenX * scale,
    y: cy - screenY * scale,
    depth: depth
  };
}

function fitView3D(nodes){
  if(!nodes || nodes.length===0) return;
  let minX=Infinity, minY=Infinity, minZ=Infinity;
  let maxX=-Infinity, maxY=-Infinity, maxZ=-Infinity;
  for(const n of nodes){
    minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
    minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
    minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z);
  }
  const cx = (minX+maxX)/2, cy = (minY+maxY)/2, cz = (minZ+maxZ)/2;
  const span = Math.max(maxX-minX, maxY-minY, maxZ-minZ, 50);
  
  View.cam.centerX = cx;
  View.cam.centerY = cy;
  View.cam.centerZ = cz;
  View.cam.distance = span * 2.5;
}

/* =========================
   Drawing
   ========================= */
function clearCanvas(){
  ctx.clearRect(0,0,el.canvas.width,el.canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,el.canvas.width,el.canvas.height);
}

function drawGrid3D(){
  const gridSize = 200;
  const gridStep = 20;
  
  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.08)";
  ctx.lineWidth = 0.5;
  
  // Draw XY grid at z=0
  for(let x = -gridSize; x <= gridSize; x += gridStep){
    const p1 = project3D(x, -gridSize, 0);
    const p2 = project3D(x, gridSize, 0);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
  for(let y = -gridSize; y <= gridSize; y += gridStep){
    const p1 = project3D(-gridSize, y, 0);
    const p2 = project3D(gridSize, y, 0);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
  
  // Draw axes
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(220,38,38,0.5)"; // X axis
  let p1 = project3D(0,0,0);
  let p2 = project3D(50,0,0);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.strokeStyle = "rgba(34,197,94,0.5)"; // Y axis
  p2 = project3D(0,50,0);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.strokeStyle = "rgba(59,130,246,0.5)"; // Z axis
  p2 = project3D(0,0,50);
  ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  
  ctx.restore();
}

function overlayDeflectedIfAvailable(){
  if(!Model.lastSolution) return;
  const scale = Number(el.defScale.value);
  if(!(scale > 0)) return;

  const { expanded, U } = Model.lastSolution;

  ctx.save();
  ctx.strokeStyle = "rgba(220,38,38,0.85)";
  ctx.lineWidth = 2.0;
  for(const e of expanded.elems){
    const n1 = expanded.nodes[e.ni];
    const n2 = expanded.nodes[e.nj];
    // TEMPORARY: Still reading from 3-DOF layout
    const ux1 = U[3*e.ni+0], uy1 = U[3*e.ni+1];
    const ux2 = U[3*e.nj+0], uy2 = U[3*e.nj+1];
    // TODO: Add uz1 = U[3*e.ni+2], uz2 = U[3*e.nj+2] when using 6-DOF

    const p1 = project3D(n1.x + scale*ux1, n1.y + scale*uy1, n1.z); // Using undeflected z for now
    const p2 = project3D(n2.x + scale*ux2, n2.y + scale*uy2, n2.z);

    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
  }
  ctx.restore();
}

function drawPrimary(){
  clearCanvas();
  drawGrid3D();

  // elements
  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.55)";
  ctx.lineWidth = 2.0;
  for(const e of Model.elems){
    const ni = Model.nodeById.get(e.ni);
    const nj = Model.nodeById.get(e.nj);
    if(!ni || !nj) continue;
    const a = project3D(ni.x, ni.y, ni.z);
    const b = project3D(nj.x, nj.y, nj.z);
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  }
  ctx.restore();

  // nodes
  for(const n of Model.nodes){
    const p = project3D(n.x, n.y, n.z);
    ctx.save();
    ctx.beginPath(); ctx.arc(p.x,p.y,4.2,0,Math.PI*2);
    ctx.fillStyle = "rgba(37,99,235,0.65)";
    ctx.fill();
    ctx.restore();
  }

  overlayDeflectedIfAvailable();
}

/* =========================
   Solver (TEMPORARY: Still uses 2D beam formulation - will be updated to 3D space frame)
   ========================= */
function buildExpandedModel(nSub = 10){
  const expanded = { nodes: [], elems: [], mapPrimaryToExpandedIndex: new Map() };
  const primaryNodesSorted = [...Model.nodes].slice().sort((a,b)=>a.id-b.id);

  for(const pn of primaryNodesSorted){
    const idx = expanded.nodes.length;
    expanded.nodes.push({
      x: pn.x, y: pn.y, z: pn.z,
      label: `N${pn.id}`,
      bc: {
        ux: { prescribed: pn.ux.prescribed, value: pn.ux.value },
        uy: { prescribed: pn.uy.prescribed, value: pn.uy.value },
        uz: { prescribed: pn.uz.prescribed, value: pn.uz.value },
        rx: { prescribed: pn.rx.prescribed, value: pn.rx.value },
        ry: { prescribed: pn.ry.prescribed, value: pn.ry.value },
        rz: { prescribed: pn.rz.prescribed, value: pn.rz.value }
      },
      loads: { fx: pn.loads.fx, fy: pn.loads.fy, fz: pn.loads.fz }
    });
    expanded.mapPrimaryToExpandedIndex.set(pn.id, idx);
  }

  for(const pe of Model.elems){
    const nI = Model.nodeById.get(pe.ni);
    const nJ = Model.nodeById.get(pe.nj);
    if(!nI || !nJ) continue;

    const iExp = expanded.mapPrimaryToExpandedIndex.get(pe.ni);
    const jExp = expanded.mapPrimaryToExpandedIndex.get(pe.nj);

    const internalIdx = [];
    for(let k=1;k<nSub;k++){
      const t = k / nSub;
      const idx = expanded.nodes.length;
      expanded.nodes.push({
        x: nI.x + t*(nJ.x - nI.x),
        y: nI.y + t*(nJ.y - nI.y),
        z: nI.z + t*(nJ.z - nI.z),
        label: `S${pe.id}.${k}`,
        bc: { 
          ux:{prescribed:false,value:0}, uy:{prescribed:false,value:0}, uz:{prescribed:false,value:0},
          rx:{prescribed:false,value:0}, ry:{prescribed:false,value:0}, rz:{prescribed:false,value:0}
        },
        loads: { fx:0, fy:0, fz:0 }
      });
      internalIdx.push(idx);
    }

    const chain = [iExp, ...internalIdx, jExp];
    for(let s=0; s<nSub; s++){
      expanded.elems.push({
        ni: chain[s], nj: chain[s+1],
        E: pe.E, G: pe.G, Izz: pe.Izz, Iyy: pe.Iyy, Jyz: pe.Jyz, Ayz: pe.Ayz,
        x3: pe.x3, y3: pe.y3, z3: pe.z3,
        primaryElemId: pe.id,
        subIndex: s+1
      });
    }
  }
  return expanded;
}

function solveLinearSystemDense(A, b){
  const n = b.length;
  const M = Array.from({length:n}, (_,i)=> Float64Array.from(A[i]));
  const rhs = new Float64Array(b);

  for(let k=0;k<n;k++){
    let piv = k;
    let max = Math.abs(M[k][k]);
    for(let i=k+1;i<n;i++){
      const v = Math.abs(M[i][k]);
      if(v>max){ max=v; piv=i; }
    }
    if(max === 0 || !Number.isFinite(max)) throw new Error("Singular or ill-conditioned stiffness matrix (pivot=0).");

    if(piv !== k){
      const tmpRow = M[k]; M[k] = M[piv]; M[piv] = tmpRow;
      const tmpB = rhs[k]; rhs[k] = rhs[piv]; rhs[piv] = tmpB;
    }

    const akk = M[k][k];
    for(let i=k+1;i<n;i++){
      const factor = M[i][k] / akk;
      if(factor === 0) continue;
      rhs[i] -= factor * rhs[k];
      const Mi = M[i], Mk = M[k];
      for(let j=k;j<n;j++) Mi[j] -= factor * Mk[j];
    }
  }

  const sol = new Float64Array(n);
  for(let i=n-1;i>=0;i--){
    let sum = rhs[i];
    const Mi = M[i];
    for(let j=i+1;j<n;j++) sum -= Mi[j] * sol[j];
    sol[i] = sum / Mi[i];
  }
  return sol;
}

function elementLocalStiffness(E,A,I,L){
  // TODO: Replace with 3D space frame stiffness using E, G, Ayz, Izz, Iyy, Jyz
  // For now, return minimal placeholder
  return Array.from({length:6}, ()=> new Float64Array(6));
  
  /* OLD 2D CODE - TO BE REPLACED WITH 3D SPACE FRAME (12x12)
  const EA_L = (E*A)/L;
  const EI = E*I;
  const EI_L3 = EI/(L*L*L);
  const EI_L2 = EI/(L*L);
  const EI_L1 = EI/L;
  return [
    [ EA_L,      0,         0,     -EA_L,      0,         0 ],
    [ 0,     12*EI_L3,  6*EI_L2,     0,    -12*EI_L3,  6*EI_L2 ],
    [ 0,      6*EI_L2,  4*EI_L1,     0,     -6*EI_L2,  2*EI_L1 ],
    [ -EA_L,     0,         0,      EA_L,      0,         0 ],
    [ 0,    -12*EI_L3, -6*EI_L2,     0,     12*EI_L3, -6*EI_L2 ],
    [ 0,      6*EI_L2,  2*EI_L1,     0,     -6*EI_L2,  4*EI_L1 ]
  ];
  */
}

function solveStaticExpanded(expanded){
  // TEMPORARY: Still uses 2D formulation (3 DOF per node)
  // TODO: Update to full 3D space frame (6 DOF per node)
  const N = expanded.nodes.length;
  const ndof = 3*N;

  const K = Array.from({length: ndof}, ()=> new Float64Array(ndof));
  const F = new Float64Array(ndof);
  const U = new Float64Array(ndof);

  for(let i=0;i<N;i++){
    const n = expanded.nodes[i];
    F[3*i+0] += n.loads.fx;
    F[3*i+1] += n.loads.fy;
    // F[3*i+2] would be moment mz (not implemented yet)
  }

  for(const e of expanded.elems){
    const n1 = expanded.nodes[e.ni];
    const n2 = expanded.nodes[e.nj];
    const dx = n2.x-n1.x, dy = n2.y-n1.y;
    const L = Math.hypot(dx,dy);
    if(!(L>0)) throw new Error("Zero-length element detected in expanded mesh.");
    const c = dx/L, s = dy/L;

    const k = elementLocalStiffness(e.E,e.A,e.I,L);

    const T = [
      [  c,  s, 0,  0, 0, 0 ],
      [ -s,  c, 0,  0, 0, 0 ],
      [  0,  0, 1,  0, 0, 0 ],
      [  0,  0, 0,  c, s, 0 ],
      [  0,  0, 0, -s, c, 0 ],
      [  0,  0, 0,  0, 0, 1 ]
    ];

    const tmp = Array.from({length:6}, ()=> new Float64Array(6));
    for(let i=0;i<6;i++){
      for(let j=0;j<6;j++){
        let sum = 0;
        for(let m=0;m<6;m++) sum += k[i][m] * T[m][j];
        tmp[i][j] = sum;
      }
    }
    const kg = Array.from({length:6}, ()=> new Float64Array(6));
    for(let i=0;i<6;i++){
      for(let j=0;j<6;j++){
        let sum = 0;
        for(let m=0;m<6;m++) sum += T[m][i] * tmp[m][j];
        kg[i][j] = sum;
      }
    }

    const dofs = [3*e.ni+0,3*e.ni+1,3*e.ni+2,3*e.nj+0,3*e.nj+1,3*e.nj+2];
    for(let a=0;a<6;a++){
      const Irow = dofs[a];
      const Krow = K[Irow];
      for(let b=0;b<6;b++) Krow[dofs[b]] += kg[a][b];
    }
  }

  const fixed=[], fixedVal=[], free=[];
  for(let i=0;i<N;i++){
    const bc = expanded.nodes[i].bc;
    const d0=3*i+0, d1=3*i+1, d2=3*i+2;
    if(bc.ux.prescribed){ fixed.push(d0); fixedVal.push(bc.ux.value); } else free.push(d0);
    if(bc.uy.prescribed){ fixed.push(d1); fixedVal.push(bc.uy.value); } else free.push(d1);
    if(bc.rz.prescribed){ fixed.push(d2); fixedVal.push(bc.rz.value); } else free.push(d2);
  }
  if(free.length===0) throw new Error("All DOFs are prescribed; nothing to solve.");

  const nF=free.length, nC=fixed.length;
  const Rf=new Float64Array(nF);
  for(let a=0;a<nF;a++){
    const I=free[a];
    let rhs=F[I];
    for(let b=0;b<nC;b++){
      const J=fixed[b];
      rhs -= K[I][J]*fixedVal[b];
    }
    Rf[a]=rhs;
  }
  const Kff=Array.from({length:nF}, ()=> new Float64Array(nF));
  for(let a=0;a<nF;a++){
    const I=free[a];
    for(let b=0;b<nF;b++){
      const J=free[b];
      Kff[a][b]=K[I][J];
    }
  }
  const Uf=solveLinearSystemDense(Kff,Rf);

  for(let b=0;b<nC;b++) U[fixed[b]]=fixedVal[b];
  for(let a=0;a<nF;a++) U[free[a]]=Uf[a];

  return { U, F, meta:{N,ndof,nFree:nF,nFixed:nC} };
}

function summarizeDisplacements(expanded, U){
  let maxMag = { val:-Infinity, label:"" };
  let minMag = { val:+Infinity, label:"" };
  for(let i=0;i<expanded.nodes.length;i++){
    // TEMPORARY: Still reading from 3-DOF layout (ux, uy, _)
    // TODO: Update to 6-DOF layout when solver is upgraded
    const ux = U[3*i+0], uy = U[3*i+1];
    // const uz = U[3*i+2]; // Will be displacement when using 6-DOF
    const mag = Math.hypot(ux,uy); // Should be Math.hypot(ux,uy,uz) in full 3D
    const lab = expanded.nodes[i].label || `idx${i}`;
    if(mag > maxMag.val) maxMag = { val:mag, label:lab };
    if(mag < minMag.val) minMag = { val:mag, label:lab };
  }
  return { maxMag, minMag };
}

function elementEndForcesLocal(expanded, e, U){
  // TODO: Implement 3D element force recovery
  // For now, return placeholder
  return { fL: new Float64Array(12) }; // 12 DOF for 3D beam (6 per node)
  
  /* OLD 2D CODE - TO BE REPLACED
  const n1 = expanded.nodes[e.ni];
  const n2 = expanded.nodes[e.nj];
  const dx = n2.x-n1.x, dy = n2.y-n1.y;
  const L = Math.hypot(dx,dy);
  const c = dx/L, s = dy/L;

  const uG = new Float64Array(6);
  uG[0]=U[3*e.ni+0]; uG[1]=U[3*e.ni+1]; uG[2]=U[3*e.ni+2];
  uG[3]=U[3*e.nj+0]; uG[4]=U[3*e.nj+1]; uG[5]=U[3*e.nj+2];

  const uL = new Float64Array(6);
  uL[0]= c*uG[0] + s*uG[1];
  uL[1]=-s*uG[0] + c*uG[1];
  uL[2]= uG[2];
  uL[3]= c*uG[3] + s*uG[4];
  uL[4]=-s*uG[3] + c*uG[4];
  uL[5]= uG[5];

  const kL = elementLocalStiffness(e.E,e.A,e.I,L);
  const fL = new Float64Array(6);
  for(let i=0;i<6;i++){
    let sum=0;
    for(let j=0;j<6;j++) sum += kL[i][j]*uL[j];
    fL[i]=sum;
  }
  return { fL };
  */
}

function summarizeStresses(expanded, U){
  // TODO: Implement 3D stress calculation using Ayz, Izz, Iyy, Jyz
  // For now, return placeholder values
  return { 
    maxSig: { val: 0, at: "N/A (pending 3D implementation)" }, 
    minSig: { val: 0, at: "N/A (pending 3D implementation)" } 
  };
  
  /* OLD 2D CODE - TO BE REPLACED
  let maxSig = { val:-Infinity, at:"" };
  let minSig = { val:+Infinity, at:"" };
  for(const e of expanded.elems){
    const {fL} = elementEndForcesLocal(expanded, e, U);
    const N1 = fL[0];
    const N2 = -fL[3];
    const N = 0.5*(N1+N2);
    const M1 = fL[2], M2 = fL[5];
    const Mabs = Math.max(Math.abs(M1), Math.abs(M2));
    const sigAx = N / e.A;
    const sigB = (e.S>0) ? (Mabs / e.S) : 0;
    const sigTop = sigAx + sigB;
    const sigBot = sigAx - sigB;
    const localMax = Math.max(sigTop, sigBot);
    const localMin = Math.min(sigTop, sigBot);
    const where = `seg ${e.primaryElemId}, sub ${e.subIndex}`;
    if(localMax > maxSig.val) maxSig = { val:localMax, at:where };
    if(localMin < minSig.val) minSig = { val:localMin, at:where };
  }
  return { maxSig, minSig };
  */
}

/* =========================
   UI wiring
   ========================= */
el.btnImportNodes.addEventListener('click', ()=> el.fileNodes.click());
el.btnImportElems.addEventListener('click', ()=> el.fileElems.click());

el.fileNodes.addEventListener('change', async ()=>{
  const f = el.fileNodes.files?.[0];
  if(!f) return;
  logClear(); setStatus("Reading nodes...");
  try{
    el.taNodes.value = await f.text();
    syncFromTextareas({nodes:true, elems:false, announce:true});
    logLine(`OK: Loaded nodes file "${f.name}" into textarea.`, "log-ok");
  }catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle"); el.fileNodes.value="";
});

el.fileElems.addEventListener('change', async ()=>{
  const f = el.fileElems.files?.[0];
  if(!f) return;
  logClear(); setStatus("Reading segments...");
  try{
    el.taElems.value = await f.text();
    syncFromTextareas({nodes:false, elems:true, announce:true});
    logLine(`OK: Loaded segments file "${f.name}" into textarea.`, "log-ok");
  }catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle"); el.fileElems.value="";
});

el.btnParseNodes.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing nodes...");
  try{ syncFromTextareas({nodes:true, elems:false, announce:true}); }
  catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle");
});
el.btnParseElems.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing segments...");
  try{ syncFromTextareas({nodes:false, elems:true, announce:true}); }
  catch(err){ logLine(`ERROR: ${err.message}`, "log-err"); }
  setStatus("Idle");
});

el.btnResetNodes.addEventListener('click', ()=>{
  logClear();
  el.taNodes.value = DEFAULT_NODES_TEXT;
  try{
    syncFromTextareas({nodes:true, elems:false, announce:false});
    logLine("OK: Nodes reset to defaults and installed.", "log-ok");
  }catch(err){
    logLine(`ERROR resetting nodes: ${err.message}`, "log-err");
  }
  setStatus("Idle");
});
el.btnResetElems.addEventListener('click', ()=>{
  logClear();
  el.taElems.value = DEFAULT_ELEMS_TEXT;
  try{
    syncFromTextareas({nodes:false, elems:true, announce:false});
    logLine("OK: Segments reset to defaults and installed.", "log-ok");
  }catch(err){
    logLine(`ERROR resetting segments: ${err.message}`, "log-err");
  }
  setStatus("Idle");
});

el.btnDraw.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing + validating...");
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Fix input");
    return;
  }

  if(!crossValidate()){ setStatus("Fix input"); return; }

  View.isInteractive = true;
  fitView3D(Model.nodes);
  Model.isDrawn = true;
  drawPrimary();
  setStatus("Interactive");
  logLine("OK: Frame drawn in 3D viewport.", "log-ok");
});

el.btnSolve.addEventListener('click', ()=>{
  logClear(); setStatus("Syncing + validating...");
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Fix input");
    return;
  }

  if(!crossValidate()){ setStatus("Fix input"); return; }

  try{
    setStatus("Expanding mesh...");
    const expanded = buildExpandedModel(10);

    setStatus("Solving...");
    const sol = solveStaticExpanded(expanded);

    setStatus("Post-processing...");
    const disp = summarizeDisplacements(expanded, sol.U);
    const stress = summarizeStresses(expanded, sol.U);

    Model.lastSolution = { expanded, U: sol.U, F: sol.F, meta: sol.meta, disp, stress };
    renderSummary();

    el.defScale.disabled = false;
    el.defScale.value = 0;
    el.defScaleLabel.textContent = "0";

    logLine(`OK: Static solve complete. DOF ${sol.meta.ndof} (free ${sol.meta.nFree}, fixed ${sol.meta.nFixed}).`, "log-ok");
    logLine(`Displacements (expanded): Max |u| = ${disp.maxMag.val.toFixed(4)} at ${disp.maxMag.label}`, "log-ok");
    logLine(`Displacements (expanded): Min |u| = ${disp.minMag.val.toFixed(4)} at ${disp.minMag.label}`, "log-ok");
    logLine(`Stresses: Max sigma = ${stress.maxSig.val.toFixed(2)} at ${stress.maxSig.at}`, "log-ok");
    logLine(`Stresses: Min sigma = ${stress.minSig.val.toFixed(2)} at ${stress.minSig.at}`, "log-ok");

    View.isInteractive = true;
    fitView3D(Model.nodes);
    Model.isDrawn = true;
    drawPrimary();
    setStatus("Solved (use deflection scale slider)");
  }catch(err){
    logLine(`ERROR: ${err.message}`, "log-err");
    setStatus("Solve failed");
  }
});

el.defScale.addEventListener('input', ()=>{
  el.defScaleLabel.textContent = String(el.defScale.value);
  if(Model.isDrawn) drawPrimary();
});

/* =========================
   3D Camera Controls
   ========================= */
function canvasPointFromEvent(evt){
  const r = el.canvas.getBoundingClientRect();
  return {
    x:(evt.clientX-r.left)*(el.canvas.width/r.width),
    y:(evt.clientY-r.top)*(el.canvas.height/r.height)
  };
}

el.canvas.addEventListener('mousedown',(evt)=>{
  if(!View.isInteractive) return;
  evt.preventDefault();
  View.dragging = true;
  View.dragButton = evt.button;
  const p = canvasPointFromEvent(evt);
  View.dragStart.x = p.x;
  View.dragStart.y = p.y;
  View.dragStart.azimuth = View.cam.azimuth;
  View.dragStart.elevation = View.cam.elevation;
  View.dragStart.centerX = View.cam.centerX;
  View.dragStart.centerY = View.cam.centerY;
  View.dragStart.centerZ = View.cam.centerZ;
});

window.addEventListener('mouseup',()=>{ View.dragging=false; });

window.addEventListener('mousemove',(evt)=>{
  if(!View.isInteractive || !View.dragging) return;
  const p = canvasPointFromEvent(evt);
  const dx = p.x - View.dragStart.x;
  const dy = p.y - View.dragStart.y;

  if(View.dragButton === 0){ // Left button - orbit
    View.cam.azimuth = View.dragStart.azimuth + dx * 0.01;
    View.cam.elevation = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, View.dragStart.elevation - dy * 0.01));
  } else if(View.dragButton === 2){ // Right button - pan
    const panSpeed = View.cam.distance * 0.002;
    const right = {
      x: Math.sin(View.cam.azimuth),
      y: -Math.cos(View.cam.azimuth)
    };
    const up = {
      x: Math.cos(View.cam.azimuth) * Math.sin(View.cam.elevation),
      y: Math.sin(View.cam.azimuth) * Math.sin(View.cam.elevation),
      z: Math.cos(View.cam.elevation)
    };
    
    View.cam.centerX = View.dragStart.centerX - dx * panSpeed * right.x + dy * panSpeed * up.x;
    View.cam.centerY = View.dragStart.centerY - dx * panSpeed * right.y + dy * panSpeed * up.y;
    View.cam.centerZ = View.dragStart.centerZ + dy * panSpeed * up.z;
  }
  
  if(Model.isDrawn) drawPrimary();
});

el.canvas.addEventListener('wheel',(evt)=>{
  if(!View.isInteractive) return;
  evt.preventDefault();
  const zoomFactor = Math.exp(-evt.deltaY * 0.001);
  View.cam.distance = Math.max(10, Math.min(10000, View.cam.distance * zoomFactor));
  if(Model.isDrawn) drawPrimary();
},{passive:false});

el.canvas.addEventListener('contextmenu',(evt)=>{
  evt.preventDefault(); // Prevent context menu on right-click
});

/* =========================
   Startup
   ========================= */
function init(){
  clearCanvas();
  el.taNodes.value = DEFAULT_NODES_TEXT;
  el.taElems.value = DEFAULT_ELEMS_TEXT;

  logClear();
  try{
    syncFromTextareas({nodes:true, elems:true, announce:false});
    logLine("Loaded defaults into model. Edit text and click Solve; changes take effect immediately.", "log-ok");
  }catch(err){
    logLine(`ERROR loading defaults: ${err.message}`, "log-err");
  }
  setStatus("Idle");
}
init();
</script>
</body>
</html>
